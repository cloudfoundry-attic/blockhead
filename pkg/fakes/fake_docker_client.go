// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"io"
	"sync"
	"time"

	"github.com/cloudfoundry-incubator/blockhead/pkg/containermanager/docker"
	"github.com/docker/docker/api/types"
	"github.com/docker/docker/api/types/container"
	"github.com/docker/docker/api/types/filters"
	"github.com/docker/docker/api/types/network"
	"github.com/docker/docker/api/types/registry"
	"golang.org/x/net/context"
)

type FakeDockerClient struct {
	ImageBuildStub        func(ctx context.Context, readerName io.Reader, options types.ImageBuildOptions) (types.ImageBuildResponse, error)
	imageBuildMutex       sync.RWMutex
	imageBuildArgsForCall []struct {
		ctx        context.Context
		readerName io.Reader
		options    types.ImageBuildOptions
	}
	imageBuildReturns struct {
		result1 types.ImageBuildResponse
		result2 error
	}
	imageBuildReturnsOnCall map[int]struct {
		result1 types.ImageBuildResponse
		result2 error
	}
	ImageCreateStub        func(ctx context.Context, parentReference string, options types.ImageCreateOptions) (io.ReadCloser, error)
	imageCreateMutex       sync.RWMutex
	imageCreateArgsForCall []struct {
		ctx             context.Context
		parentReference string
		options         types.ImageCreateOptions
	}
	imageCreateReturns struct {
		result1 io.ReadCloser
		result2 error
	}
	imageCreateReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 error
	}
	ImageHistoryStub        func(ctx context.Context, image string) ([]types.ImageHistory, error)
	imageHistoryMutex       sync.RWMutex
	imageHistoryArgsForCall []struct {
		ctx   context.Context
		image string
	}
	imageHistoryReturns struct {
		result1 []types.ImageHistory
		result2 error
	}
	imageHistoryReturnsOnCall map[int]struct {
		result1 []types.ImageHistory
		result2 error
	}
	ImageImportStub        func(ctx context.Context, source types.ImageImportSource, ref string, options types.ImageImportOptions) (io.ReadCloser, error)
	imageImportMutex       sync.RWMutex
	imageImportArgsForCall []struct {
		ctx     context.Context
		source  types.ImageImportSource
		ref     string
		options types.ImageImportOptions
	}
	imageImportReturns struct {
		result1 io.ReadCloser
		result2 error
	}
	imageImportReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 error
	}
	ImageInspectWithRawStub        func(ctx context.Context, image string) (types.ImageInspect, []byte, error)
	imageInspectWithRawMutex       sync.RWMutex
	imageInspectWithRawArgsForCall []struct {
		ctx   context.Context
		image string
	}
	imageInspectWithRawReturns struct {
		result1 types.ImageInspect
		result2 []byte
		result3 error
	}
	imageInspectWithRawReturnsOnCall map[int]struct {
		result1 types.ImageInspect
		result2 []byte
		result3 error
	}
	ImageListStub        func(ctx context.Context, options types.ImageListOptions) ([]types.ImageSummary, error)
	imageListMutex       sync.RWMutex
	imageListArgsForCall []struct {
		ctx     context.Context
		options types.ImageListOptions
	}
	imageListReturns struct {
		result1 []types.ImageSummary
		result2 error
	}
	imageListReturnsOnCall map[int]struct {
		result1 []types.ImageSummary
		result2 error
	}
	ImageLoadStub        func(ctx context.Context, input io.Reader, quiet bool) (types.ImageLoadResponse, error)
	imageLoadMutex       sync.RWMutex
	imageLoadArgsForCall []struct {
		ctx   context.Context
		input io.Reader
		quiet bool
	}
	imageLoadReturns struct {
		result1 types.ImageLoadResponse
		result2 error
	}
	imageLoadReturnsOnCall map[int]struct {
		result1 types.ImageLoadResponse
		result2 error
	}
	ImagePullStub        func(ctx context.Context, ref string, options types.ImagePullOptions) (io.ReadCloser, error)
	imagePullMutex       sync.RWMutex
	imagePullArgsForCall []struct {
		ctx     context.Context
		ref     string
		options types.ImagePullOptions
	}
	imagePullReturns struct {
		result1 io.ReadCloser
		result2 error
	}
	imagePullReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 error
	}
	ImagePushStub        func(ctx context.Context, ref string, options types.ImagePushOptions) (io.ReadCloser, error)
	imagePushMutex       sync.RWMutex
	imagePushArgsForCall []struct {
		ctx     context.Context
		ref     string
		options types.ImagePushOptions
	}
	imagePushReturns struct {
		result1 io.ReadCloser
		result2 error
	}
	imagePushReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 error
	}
	ImageRemoveStub        func(ctx context.Context, image string, options types.ImageRemoveOptions) ([]types.ImageDelete, error)
	imageRemoveMutex       sync.RWMutex
	imageRemoveArgsForCall []struct {
		ctx     context.Context
		image   string
		options types.ImageRemoveOptions
	}
	imageRemoveReturns struct {
		result1 []types.ImageDelete
		result2 error
	}
	imageRemoveReturnsOnCall map[int]struct {
		result1 []types.ImageDelete
		result2 error
	}
	ImageSearchStub        func(ctx context.Context, term string, options types.ImageSearchOptions) ([]registry.SearchResult, error)
	imageSearchMutex       sync.RWMutex
	imageSearchArgsForCall []struct {
		ctx     context.Context
		term    string
		options types.ImageSearchOptions
	}
	imageSearchReturns struct {
		result1 []registry.SearchResult
		result2 error
	}
	imageSearchReturnsOnCall map[int]struct {
		result1 []registry.SearchResult
		result2 error
	}
	ImageSaveStub        func(ctx context.Context, images []string) (io.ReadCloser, error)
	imageSaveMutex       sync.RWMutex
	imageSaveArgsForCall []struct {
		ctx    context.Context
		images []string
	}
	imageSaveReturns struct {
		result1 io.ReadCloser
		result2 error
	}
	imageSaveReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 error
	}
	ImageTagStub        func(ctx context.Context, image, ref string) error
	imageTagMutex       sync.RWMutex
	imageTagArgsForCall []struct {
		ctx   context.Context
		image string
		ref   string
	}
	imageTagReturns struct {
		result1 error
	}
	imageTagReturnsOnCall map[int]struct {
		result1 error
	}
	ImagesPruneStub        func(ctx context.Context, pruneFilter filters.Args) (types.ImagesPruneReport, error)
	imagesPruneMutex       sync.RWMutex
	imagesPruneArgsForCall []struct {
		ctx         context.Context
		pruneFilter filters.Args
	}
	imagesPruneReturns struct {
		result1 types.ImagesPruneReport
		result2 error
	}
	imagesPruneReturnsOnCall map[int]struct {
		result1 types.ImagesPruneReport
		result2 error
	}
	ContainerAttachStub        func(ctx context.Context, container string, options types.ContainerAttachOptions) (types.HijackedResponse, error)
	containerAttachMutex       sync.RWMutex
	containerAttachArgsForCall []struct {
		ctx       context.Context
		container string
		options   types.ContainerAttachOptions
	}
	containerAttachReturns struct {
		result1 types.HijackedResponse
		result2 error
	}
	containerAttachReturnsOnCall map[int]struct {
		result1 types.HijackedResponse
		result2 error
	}
	ContainerCommitStub        func(ctx context.Context, container string, options types.ContainerCommitOptions) (types.IDResponse, error)
	containerCommitMutex       sync.RWMutex
	containerCommitArgsForCall []struct {
		ctx       context.Context
		container string
		options   types.ContainerCommitOptions
	}
	containerCommitReturns struct {
		result1 types.IDResponse
		result2 error
	}
	containerCommitReturnsOnCall map[int]struct {
		result1 types.IDResponse
		result2 error
	}
	ContainerCreateStub        func(ctx context.Context, config *container.Config, hostConfig *container.HostConfig, networkingConfig *network.NetworkingConfig, containerName string) (container.ContainerCreateCreatedBody, error)
	containerCreateMutex       sync.RWMutex
	containerCreateArgsForCall []struct {
		ctx              context.Context
		config           *container.Config
		hostConfig       *container.HostConfig
		networkingConfig *network.NetworkingConfig
		containerName    string
	}
	containerCreateReturns struct {
		result1 container.ContainerCreateCreatedBody
		result2 error
	}
	containerCreateReturnsOnCall map[int]struct {
		result1 container.ContainerCreateCreatedBody
		result2 error
	}
	ContainerDiffStub        func(ctx context.Context, container string) ([]types.ContainerChange, error)
	containerDiffMutex       sync.RWMutex
	containerDiffArgsForCall []struct {
		ctx       context.Context
		container string
	}
	containerDiffReturns struct {
		result1 []types.ContainerChange
		result2 error
	}
	containerDiffReturnsOnCall map[int]struct {
		result1 []types.ContainerChange
		result2 error
	}
	ContainerExecAttachStub        func(ctx context.Context, execID string, config types.ExecConfig) (types.HijackedResponse, error)
	containerExecAttachMutex       sync.RWMutex
	containerExecAttachArgsForCall []struct {
		ctx    context.Context
		execID string
		config types.ExecConfig
	}
	containerExecAttachReturns struct {
		result1 types.HijackedResponse
		result2 error
	}
	containerExecAttachReturnsOnCall map[int]struct {
		result1 types.HijackedResponse
		result2 error
	}
	ContainerExecCreateStub        func(ctx context.Context, container string, config types.ExecConfig) (types.IDResponse, error)
	containerExecCreateMutex       sync.RWMutex
	containerExecCreateArgsForCall []struct {
		ctx       context.Context
		container string
		config    types.ExecConfig
	}
	containerExecCreateReturns struct {
		result1 types.IDResponse
		result2 error
	}
	containerExecCreateReturnsOnCall map[int]struct {
		result1 types.IDResponse
		result2 error
	}
	ContainerExecInspectStub        func(ctx context.Context, execID string) (types.ContainerExecInspect, error)
	containerExecInspectMutex       sync.RWMutex
	containerExecInspectArgsForCall []struct {
		ctx    context.Context
		execID string
	}
	containerExecInspectReturns struct {
		result1 types.ContainerExecInspect
		result2 error
	}
	containerExecInspectReturnsOnCall map[int]struct {
		result1 types.ContainerExecInspect
		result2 error
	}
	ContainerExecResizeStub        func(ctx context.Context, execID string, options types.ResizeOptions) error
	containerExecResizeMutex       sync.RWMutex
	containerExecResizeArgsForCall []struct {
		ctx     context.Context
		execID  string
		options types.ResizeOptions
	}
	containerExecResizeReturns struct {
		result1 error
	}
	containerExecResizeReturnsOnCall map[int]struct {
		result1 error
	}
	ContainerExecStartStub        func(ctx context.Context, execID string, config types.ExecStartCheck) error
	containerExecStartMutex       sync.RWMutex
	containerExecStartArgsForCall []struct {
		ctx    context.Context
		execID string
		config types.ExecStartCheck
	}
	containerExecStartReturns struct {
		result1 error
	}
	containerExecStartReturnsOnCall map[int]struct {
		result1 error
	}
	ContainerExportStub        func(ctx context.Context, container string) (io.ReadCloser, error)
	containerExportMutex       sync.RWMutex
	containerExportArgsForCall []struct {
		ctx       context.Context
		container string
	}
	containerExportReturns struct {
		result1 io.ReadCloser
		result2 error
	}
	containerExportReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 error
	}
	ContainerInspectStub        func(ctx context.Context, container string) (types.ContainerJSON, error)
	containerInspectMutex       sync.RWMutex
	containerInspectArgsForCall []struct {
		ctx       context.Context
		container string
	}
	containerInspectReturns struct {
		result1 types.ContainerJSON
		result2 error
	}
	containerInspectReturnsOnCall map[int]struct {
		result1 types.ContainerJSON
		result2 error
	}
	ContainerInspectWithRawStub        func(ctx context.Context, container string, getSize bool) (types.ContainerJSON, []byte, error)
	containerInspectWithRawMutex       sync.RWMutex
	containerInspectWithRawArgsForCall []struct {
		ctx       context.Context
		container string
		getSize   bool
	}
	containerInspectWithRawReturns struct {
		result1 types.ContainerJSON
		result2 []byte
		result3 error
	}
	containerInspectWithRawReturnsOnCall map[int]struct {
		result1 types.ContainerJSON
		result2 []byte
		result3 error
	}
	ContainerKillStub        func(ctx context.Context, container, signal string) error
	containerKillMutex       sync.RWMutex
	containerKillArgsForCall []struct {
		ctx       context.Context
		container string
		signal    string
	}
	containerKillReturns struct {
		result1 error
	}
	containerKillReturnsOnCall map[int]struct {
		result1 error
	}
	ContainerListStub        func(ctx context.Context, options types.ContainerListOptions) ([]types.Container, error)
	containerListMutex       sync.RWMutex
	containerListArgsForCall []struct {
		ctx     context.Context
		options types.ContainerListOptions
	}
	containerListReturns struct {
		result1 []types.Container
		result2 error
	}
	containerListReturnsOnCall map[int]struct {
		result1 []types.Container
		result2 error
	}
	ContainerLogsStub        func(ctx context.Context, container string, options types.ContainerLogsOptions) (io.ReadCloser, error)
	containerLogsMutex       sync.RWMutex
	containerLogsArgsForCall []struct {
		ctx       context.Context
		container string
		options   types.ContainerLogsOptions
	}
	containerLogsReturns struct {
		result1 io.ReadCloser
		result2 error
	}
	containerLogsReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 error
	}
	ContainerPauseStub        func(ctx context.Context, container string) error
	containerPauseMutex       sync.RWMutex
	containerPauseArgsForCall []struct {
		ctx       context.Context
		container string
	}
	containerPauseReturns struct {
		result1 error
	}
	containerPauseReturnsOnCall map[int]struct {
		result1 error
	}
	ContainerRemoveStub        func(ctx context.Context, container string, options types.ContainerRemoveOptions) error
	containerRemoveMutex       sync.RWMutex
	containerRemoveArgsForCall []struct {
		ctx       context.Context
		container string
		options   types.ContainerRemoveOptions
	}
	containerRemoveReturns struct {
		result1 error
	}
	containerRemoveReturnsOnCall map[int]struct {
		result1 error
	}
	ContainerRenameStub        func(ctx context.Context, container, newContainerName string) error
	containerRenameMutex       sync.RWMutex
	containerRenameArgsForCall []struct {
		ctx              context.Context
		container        string
		newContainerName string
	}
	containerRenameReturns struct {
		result1 error
	}
	containerRenameReturnsOnCall map[int]struct {
		result1 error
	}
	ContainerResizeStub        func(ctx context.Context, container string, options types.ResizeOptions) error
	containerResizeMutex       sync.RWMutex
	containerResizeArgsForCall []struct {
		ctx       context.Context
		container string
		options   types.ResizeOptions
	}
	containerResizeReturns struct {
		result1 error
	}
	containerResizeReturnsOnCall map[int]struct {
		result1 error
	}
	ContainerRestartStub        func(ctx context.Context, container string, timeout *time.Duration) error
	containerRestartMutex       sync.RWMutex
	containerRestartArgsForCall []struct {
		ctx       context.Context
		container string
		timeout   *time.Duration
	}
	containerRestartReturns struct {
		result1 error
	}
	containerRestartReturnsOnCall map[int]struct {
		result1 error
	}
	ContainerStatPathStub        func(ctx context.Context, container, path string) (types.ContainerPathStat, error)
	containerStatPathMutex       sync.RWMutex
	containerStatPathArgsForCall []struct {
		ctx       context.Context
		container string
		path      string
	}
	containerStatPathReturns struct {
		result1 types.ContainerPathStat
		result2 error
	}
	containerStatPathReturnsOnCall map[int]struct {
		result1 types.ContainerPathStat
		result2 error
	}
	ContainerStatsStub        func(ctx context.Context, container string, stream bool) (types.ContainerStats, error)
	containerStatsMutex       sync.RWMutex
	containerStatsArgsForCall []struct {
		ctx       context.Context
		container string
		stream    bool
	}
	containerStatsReturns struct {
		result1 types.ContainerStats
		result2 error
	}
	containerStatsReturnsOnCall map[int]struct {
		result1 types.ContainerStats
		result2 error
	}
	ContainerStartStub        func(ctx context.Context, container string, options types.ContainerStartOptions) error
	containerStartMutex       sync.RWMutex
	containerStartArgsForCall []struct {
		ctx       context.Context
		container string
		options   types.ContainerStartOptions
	}
	containerStartReturns struct {
		result1 error
	}
	containerStartReturnsOnCall map[int]struct {
		result1 error
	}
	ContainerStopStub        func(ctx context.Context, container string, timeout *time.Duration) error
	containerStopMutex       sync.RWMutex
	containerStopArgsForCall []struct {
		ctx       context.Context
		container string
		timeout   *time.Duration
	}
	containerStopReturns struct {
		result1 error
	}
	containerStopReturnsOnCall map[int]struct {
		result1 error
	}
	ContainerTopStub        func(ctx context.Context, container string, arguments []string) (types.ContainerProcessList, error)
	containerTopMutex       sync.RWMutex
	containerTopArgsForCall []struct {
		ctx       context.Context
		container string
		arguments []string
	}
	containerTopReturns struct {
		result1 types.ContainerProcessList
		result2 error
	}
	containerTopReturnsOnCall map[int]struct {
		result1 types.ContainerProcessList
		result2 error
	}
	ContainerUnpauseStub        func(ctx context.Context, container string) error
	containerUnpauseMutex       sync.RWMutex
	containerUnpauseArgsForCall []struct {
		ctx       context.Context
		container string
	}
	containerUnpauseReturns struct {
		result1 error
	}
	containerUnpauseReturnsOnCall map[int]struct {
		result1 error
	}
	ContainerUpdateStub        func(ctx context.Context, containerName string, updateConfig container.UpdateConfig) (container.ContainerUpdateOKBody, error)
	containerUpdateMutex       sync.RWMutex
	containerUpdateArgsForCall []struct {
		ctx           context.Context
		containerName string
		updateConfig  container.UpdateConfig
	}
	containerUpdateReturns struct {
		result1 container.ContainerUpdateOKBody
		result2 error
	}
	containerUpdateReturnsOnCall map[int]struct {
		result1 container.ContainerUpdateOKBody
		result2 error
	}
	ContainerWaitStub        func(ctx context.Context, container string) (int64, error)
	containerWaitMutex       sync.RWMutex
	containerWaitArgsForCall []struct {
		ctx       context.Context
		container string
	}
	containerWaitReturns struct {
		result1 int64
		result2 error
	}
	containerWaitReturnsOnCall map[int]struct {
		result1 int64
		result2 error
	}
	CopyFromContainerStub        func(ctx context.Context, container, srcPath string) (io.ReadCloser, types.ContainerPathStat, error)
	copyFromContainerMutex       sync.RWMutex
	copyFromContainerArgsForCall []struct {
		ctx       context.Context
		container string
		srcPath   string
	}
	copyFromContainerReturns struct {
		result1 io.ReadCloser
		result2 types.ContainerPathStat
		result3 error
	}
	copyFromContainerReturnsOnCall map[int]struct {
		result1 io.ReadCloser
		result2 types.ContainerPathStat
		result3 error
	}
	CopyToContainerStub        func(ctx context.Context, container, path string, content io.Reader, options types.CopyToContainerOptions) error
	copyToContainerMutex       sync.RWMutex
	copyToContainerArgsForCall []struct {
		ctx       context.Context
		container string
		path      string
		content   io.Reader
		options   types.CopyToContainerOptions
	}
	copyToContainerReturns struct {
		result1 error
	}
	copyToContainerReturnsOnCall map[int]struct {
		result1 error
	}
	ContainersPruneStub        func(ctx context.Context, pruneFilters filters.Args) (types.ContainersPruneReport, error)
	containersPruneMutex       sync.RWMutex
	containersPruneArgsForCall []struct {
		ctx          context.Context
		pruneFilters filters.Args
	}
	containersPruneReturns struct {
		result1 types.ContainersPruneReport
		result2 error
	}
	containersPruneReturnsOnCall map[int]struct {
		result1 types.ContainersPruneReport
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeDockerClient) ImageBuild(ctx context.Context, readerName io.Reader, options types.ImageBuildOptions) (types.ImageBuildResponse, error) {
	fake.imageBuildMutex.Lock()
	ret, specificReturn := fake.imageBuildReturnsOnCall[len(fake.imageBuildArgsForCall)]
	fake.imageBuildArgsForCall = append(fake.imageBuildArgsForCall, struct {
		ctx        context.Context
		readerName io.Reader
		options    types.ImageBuildOptions
	}{ctx, readerName, options})
	fake.recordInvocation("ImageBuild", []interface{}{ctx, readerName, options})
	fake.imageBuildMutex.Unlock()
	if fake.ImageBuildStub != nil {
		return fake.ImageBuildStub(ctx, readerName, options)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.imageBuildReturns.result1, fake.imageBuildReturns.result2
}

func (fake *FakeDockerClient) ImageBuildCallCount() int {
	fake.imageBuildMutex.RLock()
	defer fake.imageBuildMutex.RUnlock()
	return len(fake.imageBuildArgsForCall)
}

func (fake *FakeDockerClient) ImageBuildArgsForCall(i int) (context.Context, io.Reader, types.ImageBuildOptions) {
	fake.imageBuildMutex.RLock()
	defer fake.imageBuildMutex.RUnlock()
	return fake.imageBuildArgsForCall[i].ctx, fake.imageBuildArgsForCall[i].readerName, fake.imageBuildArgsForCall[i].options
}

func (fake *FakeDockerClient) ImageBuildReturns(result1 types.ImageBuildResponse, result2 error) {
	fake.ImageBuildStub = nil
	fake.imageBuildReturns = struct {
		result1 types.ImageBuildResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerClient) ImageBuildReturnsOnCall(i int, result1 types.ImageBuildResponse, result2 error) {
	fake.ImageBuildStub = nil
	if fake.imageBuildReturnsOnCall == nil {
		fake.imageBuildReturnsOnCall = make(map[int]struct {
			result1 types.ImageBuildResponse
			result2 error
		})
	}
	fake.imageBuildReturnsOnCall[i] = struct {
		result1 types.ImageBuildResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerClient) ImageCreate(ctx context.Context, parentReference string, options types.ImageCreateOptions) (io.ReadCloser, error) {
	fake.imageCreateMutex.Lock()
	ret, specificReturn := fake.imageCreateReturnsOnCall[len(fake.imageCreateArgsForCall)]
	fake.imageCreateArgsForCall = append(fake.imageCreateArgsForCall, struct {
		ctx             context.Context
		parentReference string
		options         types.ImageCreateOptions
	}{ctx, parentReference, options})
	fake.recordInvocation("ImageCreate", []interface{}{ctx, parentReference, options})
	fake.imageCreateMutex.Unlock()
	if fake.ImageCreateStub != nil {
		return fake.ImageCreateStub(ctx, parentReference, options)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.imageCreateReturns.result1, fake.imageCreateReturns.result2
}

func (fake *FakeDockerClient) ImageCreateCallCount() int {
	fake.imageCreateMutex.RLock()
	defer fake.imageCreateMutex.RUnlock()
	return len(fake.imageCreateArgsForCall)
}

func (fake *FakeDockerClient) ImageCreateArgsForCall(i int) (context.Context, string, types.ImageCreateOptions) {
	fake.imageCreateMutex.RLock()
	defer fake.imageCreateMutex.RUnlock()
	return fake.imageCreateArgsForCall[i].ctx, fake.imageCreateArgsForCall[i].parentReference, fake.imageCreateArgsForCall[i].options
}

func (fake *FakeDockerClient) ImageCreateReturns(result1 io.ReadCloser, result2 error) {
	fake.ImageCreateStub = nil
	fake.imageCreateReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerClient) ImageCreateReturnsOnCall(i int, result1 io.ReadCloser, result2 error) {
	fake.ImageCreateStub = nil
	if fake.imageCreateReturnsOnCall == nil {
		fake.imageCreateReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 error
		})
	}
	fake.imageCreateReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerClient) ImageHistory(ctx context.Context, image string) ([]types.ImageHistory, error) {
	fake.imageHistoryMutex.Lock()
	ret, specificReturn := fake.imageHistoryReturnsOnCall[len(fake.imageHistoryArgsForCall)]
	fake.imageHistoryArgsForCall = append(fake.imageHistoryArgsForCall, struct {
		ctx   context.Context
		image string
	}{ctx, image})
	fake.recordInvocation("ImageHistory", []interface{}{ctx, image})
	fake.imageHistoryMutex.Unlock()
	if fake.ImageHistoryStub != nil {
		return fake.ImageHistoryStub(ctx, image)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.imageHistoryReturns.result1, fake.imageHistoryReturns.result2
}

func (fake *FakeDockerClient) ImageHistoryCallCount() int {
	fake.imageHistoryMutex.RLock()
	defer fake.imageHistoryMutex.RUnlock()
	return len(fake.imageHistoryArgsForCall)
}

func (fake *FakeDockerClient) ImageHistoryArgsForCall(i int) (context.Context, string) {
	fake.imageHistoryMutex.RLock()
	defer fake.imageHistoryMutex.RUnlock()
	return fake.imageHistoryArgsForCall[i].ctx, fake.imageHistoryArgsForCall[i].image
}

func (fake *FakeDockerClient) ImageHistoryReturns(result1 []types.ImageHistory, result2 error) {
	fake.ImageHistoryStub = nil
	fake.imageHistoryReturns = struct {
		result1 []types.ImageHistory
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerClient) ImageHistoryReturnsOnCall(i int, result1 []types.ImageHistory, result2 error) {
	fake.ImageHistoryStub = nil
	if fake.imageHistoryReturnsOnCall == nil {
		fake.imageHistoryReturnsOnCall = make(map[int]struct {
			result1 []types.ImageHistory
			result2 error
		})
	}
	fake.imageHistoryReturnsOnCall[i] = struct {
		result1 []types.ImageHistory
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerClient) ImageImport(ctx context.Context, source types.ImageImportSource, ref string, options types.ImageImportOptions) (io.ReadCloser, error) {
	fake.imageImportMutex.Lock()
	ret, specificReturn := fake.imageImportReturnsOnCall[len(fake.imageImportArgsForCall)]
	fake.imageImportArgsForCall = append(fake.imageImportArgsForCall, struct {
		ctx     context.Context
		source  types.ImageImportSource
		ref     string
		options types.ImageImportOptions
	}{ctx, source, ref, options})
	fake.recordInvocation("ImageImport", []interface{}{ctx, source, ref, options})
	fake.imageImportMutex.Unlock()
	if fake.ImageImportStub != nil {
		return fake.ImageImportStub(ctx, source, ref, options)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.imageImportReturns.result1, fake.imageImportReturns.result2
}

func (fake *FakeDockerClient) ImageImportCallCount() int {
	fake.imageImportMutex.RLock()
	defer fake.imageImportMutex.RUnlock()
	return len(fake.imageImportArgsForCall)
}

func (fake *FakeDockerClient) ImageImportArgsForCall(i int) (context.Context, types.ImageImportSource, string, types.ImageImportOptions) {
	fake.imageImportMutex.RLock()
	defer fake.imageImportMutex.RUnlock()
	return fake.imageImportArgsForCall[i].ctx, fake.imageImportArgsForCall[i].source, fake.imageImportArgsForCall[i].ref, fake.imageImportArgsForCall[i].options
}

func (fake *FakeDockerClient) ImageImportReturns(result1 io.ReadCloser, result2 error) {
	fake.ImageImportStub = nil
	fake.imageImportReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerClient) ImageImportReturnsOnCall(i int, result1 io.ReadCloser, result2 error) {
	fake.ImageImportStub = nil
	if fake.imageImportReturnsOnCall == nil {
		fake.imageImportReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 error
		})
	}
	fake.imageImportReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerClient) ImageInspectWithRaw(ctx context.Context, image string) (types.ImageInspect, []byte, error) {
	fake.imageInspectWithRawMutex.Lock()
	ret, specificReturn := fake.imageInspectWithRawReturnsOnCall[len(fake.imageInspectWithRawArgsForCall)]
	fake.imageInspectWithRawArgsForCall = append(fake.imageInspectWithRawArgsForCall, struct {
		ctx   context.Context
		image string
	}{ctx, image})
	fake.recordInvocation("ImageInspectWithRaw", []interface{}{ctx, image})
	fake.imageInspectWithRawMutex.Unlock()
	if fake.ImageInspectWithRawStub != nil {
		return fake.ImageInspectWithRawStub(ctx, image)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.imageInspectWithRawReturns.result1, fake.imageInspectWithRawReturns.result2, fake.imageInspectWithRawReturns.result3
}

func (fake *FakeDockerClient) ImageInspectWithRawCallCount() int {
	fake.imageInspectWithRawMutex.RLock()
	defer fake.imageInspectWithRawMutex.RUnlock()
	return len(fake.imageInspectWithRawArgsForCall)
}

func (fake *FakeDockerClient) ImageInspectWithRawArgsForCall(i int) (context.Context, string) {
	fake.imageInspectWithRawMutex.RLock()
	defer fake.imageInspectWithRawMutex.RUnlock()
	return fake.imageInspectWithRawArgsForCall[i].ctx, fake.imageInspectWithRawArgsForCall[i].image
}

func (fake *FakeDockerClient) ImageInspectWithRawReturns(result1 types.ImageInspect, result2 []byte, result3 error) {
	fake.ImageInspectWithRawStub = nil
	fake.imageInspectWithRawReturns = struct {
		result1 types.ImageInspect
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDockerClient) ImageInspectWithRawReturnsOnCall(i int, result1 types.ImageInspect, result2 []byte, result3 error) {
	fake.ImageInspectWithRawStub = nil
	if fake.imageInspectWithRawReturnsOnCall == nil {
		fake.imageInspectWithRawReturnsOnCall = make(map[int]struct {
			result1 types.ImageInspect
			result2 []byte
			result3 error
		})
	}
	fake.imageInspectWithRawReturnsOnCall[i] = struct {
		result1 types.ImageInspect
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDockerClient) ImageList(ctx context.Context, options types.ImageListOptions) ([]types.ImageSummary, error) {
	fake.imageListMutex.Lock()
	ret, specificReturn := fake.imageListReturnsOnCall[len(fake.imageListArgsForCall)]
	fake.imageListArgsForCall = append(fake.imageListArgsForCall, struct {
		ctx     context.Context
		options types.ImageListOptions
	}{ctx, options})
	fake.recordInvocation("ImageList", []interface{}{ctx, options})
	fake.imageListMutex.Unlock()
	if fake.ImageListStub != nil {
		return fake.ImageListStub(ctx, options)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.imageListReturns.result1, fake.imageListReturns.result2
}

func (fake *FakeDockerClient) ImageListCallCount() int {
	fake.imageListMutex.RLock()
	defer fake.imageListMutex.RUnlock()
	return len(fake.imageListArgsForCall)
}

func (fake *FakeDockerClient) ImageListArgsForCall(i int) (context.Context, types.ImageListOptions) {
	fake.imageListMutex.RLock()
	defer fake.imageListMutex.RUnlock()
	return fake.imageListArgsForCall[i].ctx, fake.imageListArgsForCall[i].options
}

func (fake *FakeDockerClient) ImageListReturns(result1 []types.ImageSummary, result2 error) {
	fake.ImageListStub = nil
	fake.imageListReturns = struct {
		result1 []types.ImageSummary
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerClient) ImageListReturnsOnCall(i int, result1 []types.ImageSummary, result2 error) {
	fake.ImageListStub = nil
	if fake.imageListReturnsOnCall == nil {
		fake.imageListReturnsOnCall = make(map[int]struct {
			result1 []types.ImageSummary
			result2 error
		})
	}
	fake.imageListReturnsOnCall[i] = struct {
		result1 []types.ImageSummary
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerClient) ImageLoad(ctx context.Context, input io.Reader, quiet bool) (types.ImageLoadResponse, error) {
	fake.imageLoadMutex.Lock()
	ret, specificReturn := fake.imageLoadReturnsOnCall[len(fake.imageLoadArgsForCall)]
	fake.imageLoadArgsForCall = append(fake.imageLoadArgsForCall, struct {
		ctx   context.Context
		input io.Reader
		quiet bool
	}{ctx, input, quiet})
	fake.recordInvocation("ImageLoad", []interface{}{ctx, input, quiet})
	fake.imageLoadMutex.Unlock()
	if fake.ImageLoadStub != nil {
		return fake.ImageLoadStub(ctx, input, quiet)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.imageLoadReturns.result1, fake.imageLoadReturns.result2
}

func (fake *FakeDockerClient) ImageLoadCallCount() int {
	fake.imageLoadMutex.RLock()
	defer fake.imageLoadMutex.RUnlock()
	return len(fake.imageLoadArgsForCall)
}

func (fake *FakeDockerClient) ImageLoadArgsForCall(i int) (context.Context, io.Reader, bool) {
	fake.imageLoadMutex.RLock()
	defer fake.imageLoadMutex.RUnlock()
	return fake.imageLoadArgsForCall[i].ctx, fake.imageLoadArgsForCall[i].input, fake.imageLoadArgsForCall[i].quiet
}

func (fake *FakeDockerClient) ImageLoadReturns(result1 types.ImageLoadResponse, result2 error) {
	fake.ImageLoadStub = nil
	fake.imageLoadReturns = struct {
		result1 types.ImageLoadResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerClient) ImageLoadReturnsOnCall(i int, result1 types.ImageLoadResponse, result2 error) {
	fake.ImageLoadStub = nil
	if fake.imageLoadReturnsOnCall == nil {
		fake.imageLoadReturnsOnCall = make(map[int]struct {
			result1 types.ImageLoadResponse
			result2 error
		})
	}
	fake.imageLoadReturnsOnCall[i] = struct {
		result1 types.ImageLoadResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerClient) ImagePull(ctx context.Context, ref string, options types.ImagePullOptions) (io.ReadCloser, error) {
	fake.imagePullMutex.Lock()
	ret, specificReturn := fake.imagePullReturnsOnCall[len(fake.imagePullArgsForCall)]
	fake.imagePullArgsForCall = append(fake.imagePullArgsForCall, struct {
		ctx     context.Context
		ref     string
		options types.ImagePullOptions
	}{ctx, ref, options})
	fake.recordInvocation("ImagePull", []interface{}{ctx, ref, options})
	fake.imagePullMutex.Unlock()
	if fake.ImagePullStub != nil {
		return fake.ImagePullStub(ctx, ref, options)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.imagePullReturns.result1, fake.imagePullReturns.result2
}

func (fake *FakeDockerClient) ImagePullCallCount() int {
	fake.imagePullMutex.RLock()
	defer fake.imagePullMutex.RUnlock()
	return len(fake.imagePullArgsForCall)
}

func (fake *FakeDockerClient) ImagePullArgsForCall(i int) (context.Context, string, types.ImagePullOptions) {
	fake.imagePullMutex.RLock()
	defer fake.imagePullMutex.RUnlock()
	return fake.imagePullArgsForCall[i].ctx, fake.imagePullArgsForCall[i].ref, fake.imagePullArgsForCall[i].options
}

func (fake *FakeDockerClient) ImagePullReturns(result1 io.ReadCloser, result2 error) {
	fake.ImagePullStub = nil
	fake.imagePullReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerClient) ImagePullReturnsOnCall(i int, result1 io.ReadCloser, result2 error) {
	fake.ImagePullStub = nil
	if fake.imagePullReturnsOnCall == nil {
		fake.imagePullReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 error
		})
	}
	fake.imagePullReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerClient) ImagePush(ctx context.Context, ref string, options types.ImagePushOptions) (io.ReadCloser, error) {
	fake.imagePushMutex.Lock()
	ret, specificReturn := fake.imagePushReturnsOnCall[len(fake.imagePushArgsForCall)]
	fake.imagePushArgsForCall = append(fake.imagePushArgsForCall, struct {
		ctx     context.Context
		ref     string
		options types.ImagePushOptions
	}{ctx, ref, options})
	fake.recordInvocation("ImagePush", []interface{}{ctx, ref, options})
	fake.imagePushMutex.Unlock()
	if fake.ImagePushStub != nil {
		return fake.ImagePushStub(ctx, ref, options)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.imagePushReturns.result1, fake.imagePushReturns.result2
}

func (fake *FakeDockerClient) ImagePushCallCount() int {
	fake.imagePushMutex.RLock()
	defer fake.imagePushMutex.RUnlock()
	return len(fake.imagePushArgsForCall)
}

func (fake *FakeDockerClient) ImagePushArgsForCall(i int) (context.Context, string, types.ImagePushOptions) {
	fake.imagePushMutex.RLock()
	defer fake.imagePushMutex.RUnlock()
	return fake.imagePushArgsForCall[i].ctx, fake.imagePushArgsForCall[i].ref, fake.imagePushArgsForCall[i].options
}

func (fake *FakeDockerClient) ImagePushReturns(result1 io.ReadCloser, result2 error) {
	fake.ImagePushStub = nil
	fake.imagePushReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerClient) ImagePushReturnsOnCall(i int, result1 io.ReadCloser, result2 error) {
	fake.ImagePushStub = nil
	if fake.imagePushReturnsOnCall == nil {
		fake.imagePushReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 error
		})
	}
	fake.imagePushReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerClient) ImageRemove(ctx context.Context, image string, options types.ImageRemoveOptions) ([]types.ImageDelete, error) {
	fake.imageRemoveMutex.Lock()
	ret, specificReturn := fake.imageRemoveReturnsOnCall[len(fake.imageRemoveArgsForCall)]
	fake.imageRemoveArgsForCall = append(fake.imageRemoveArgsForCall, struct {
		ctx     context.Context
		image   string
		options types.ImageRemoveOptions
	}{ctx, image, options})
	fake.recordInvocation("ImageRemove", []interface{}{ctx, image, options})
	fake.imageRemoveMutex.Unlock()
	if fake.ImageRemoveStub != nil {
		return fake.ImageRemoveStub(ctx, image, options)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.imageRemoveReturns.result1, fake.imageRemoveReturns.result2
}

func (fake *FakeDockerClient) ImageRemoveCallCount() int {
	fake.imageRemoveMutex.RLock()
	defer fake.imageRemoveMutex.RUnlock()
	return len(fake.imageRemoveArgsForCall)
}

func (fake *FakeDockerClient) ImageRemoveArgsForCall(i int) (context.Context, string, types.ImageRemoveOptions) {
	fake.imageRemoveMutex.RLock()
	defer fake.imageRemoveMutex.RUnlock()
	return fake.imageRemoveArgsForCall[i].ctx, fake.imageRemoveArgsForCall[i].image, fake.imageRemoveArgsForCall[i].options
}

func (fake *FakeDockerClient) ImageRemoveReturns(result1 []types.ImageDelete, result2 error) {
	fake.ImageRemoveStub = nil
	fake.imageRemoveReturns = struct {
		result1 []types.ImageDelete
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerClient) ImageRemoveReturnsOnCall(i int, result1 []types.ImageDelete, result2 error) {
	fake.ImageRemoveStub = nil
	if fake.imageRemoveReturnsOnCall == nil {
		fake.imageRemoveReturnsOnCall = make(map[int]struct {
			result1 []types.ImageDelete
			result2 error
		})
	}
	fake.imageRemoveReturnsOnCall[i] = struct {
		result1 []types.ImageDelete
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerClient) ImageSearch(ctx context.Context, term string, options types.ImageSearchOptions) ([]registry.SearchResult, error) {
	fake.imageSearchMutex.Lock()
	ret, specificReturn := fake.imageSearchReturnsOnCall[len(fake.imageSearchArgsForCall)]
	fake.imageSearchArgsForCall = append(fake.imageSearchArgsForCall, struct {
		ctx     context.Context
		term    string
		options types.ImageSearchOptions
	}{ctx, term, options})
	fake.recordInvocation("ImageSearch", []interface{}{ctx, term, options})
	fake.imageSearchMutex.Unlock()
	if fake.ImageSearchStub != nil {
		return fake.ImageSearchStub(ctx, term, options)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.imageSearchReturns.result1, fake.imageSearchReturns.result2
}

func (fake *FakeDockerClient) ImageSearchCallCount() int {
	fake.imageSearchMutex.RLock()
	defer fake.imageSearchMutex.RUnlock()
	return len(fake.imageSearchArgsForCall)
}

func (fake *FakeDockerClient) ImageSearchArgsForCall(i int) (context.Context, string, types.ImageSearchOptions) {
	fake.imageSearchMutex.RLock()
	defer fake.imageSearchMutex.RUnlock()
	return fake.imageSearchArgsForCall[i].ctx, fake.imageSearchArgsForCall[i].term, fake.imageSearchArgsForCall[i].options
}

func (fake *FakeDockerClient) ImageSearchReturns(result1 []registry.SearchResult, result2 error) {
	fake.ImageSearchStub = nil
	fake.imageSearchReturns = struct {
		result1 []registry.SearchResult
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerClient) ImageSearchReturnsOnCall(i int, result1 []registry.SearchResult, result2 error) {
	fake.ImageSearchStub = nil
	if fake.imageSearchReturnsOnCall == nil {
		fake.imageSearchReturnsOnCall = make(map[int]struct {
			result1 []registry.SearchResult
			result2 error
		})
	}
	fake.imageSearchReturnsOnCall[i] = struct {
		result1 []registry.SearchResult
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerClient) ImageSave(ctx context.Context, images []string) (io.ReadCloser, error) {
	var imagesCopy []string
	if images != nil {
		imagesCopy = make([]string, len(images))
		copy(imagesCopy, images)
	}
	fake.imageSaveMutex.Lock()
	ret, specificReturn := fake.imageSaveReturnsOnCall[len(fake.imageSaveArgsForCall)]
	fake.imageSaveArgsForCall = append(fake.imageSaveArgsForCall, struct {
		ctx    context.Context
		images []string
	}{ctx, imagesCopy})
	fake.recordInvocation("ImageSave", []interface{}{ctx, imagesCopy})
	fake.imageSaveMutex.Unlock()
	if fake.ImageSaveStub != nil {
		return fake.ImageSaveStub(ctx, images)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.imageSaveReturns.result1, fake.imageSaveReturns.result2
}

func (fake *FakeDockerClient) ImageSaveCallCount() int {
	fake.imageSaveMutex.RLock()
	defer fake.imageSaveMutex.RUnlock()
	return len(fake.imageSaveArgsForCall)
}

func (fake *FakeDockerClient) ImageSaveArgsForCall(i int) (context.Context, []string) {
	fake.imageSaveMutex.RLock()
	defer fake.imageSaveMutex.RUnlock()
	return fake.imageSaveArgsForCall[i].ctx, fake.imageSaveArgsForCall[i].images
}

func (fake *FakeDockerClient) ImageSaveReturns(result1 io.ReadCloser, result2 error) {
	fake.ImageSaveStub = nil
	fake.imageSaveReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerClient) ImageSaveReturnsOnCall(i int, result1 io.ReadCloser, result2 error) {
	fake.ImageSaveStub = nil
	if fake.imageSaveReturnsOnCall == nil {
		fake.imageSaveReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 error
		})
	}
	fake.imageSaveReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerClient) ImageTag(ctx context.Context, image string, ref string) error {
	fake.imageTagMutex.Lock()
	ret, specificReturn := fake.imageTagReturnsOnCall[len(fake.imageTagArgsForCall)]
	fake.imageTagArgsForCall = append(fake.imageTagArgsForCall, struct {
		ctx   context.Context
		image string
		ref   string
	}{ctx, image, ref})
	fake.recordInvocation("ImageTag", []interface{}{ctx, image, ref})
	fake.imageTagMutex.Unlock()
	if fake.ImageTagStub != nil {
		return fake.ImageTagStub(ctx, image, ref)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.imageTagReturns.result1
}

func (fake *FakeDockerClient) ImageTagCallCount() int {
	fake.imageTagMutex.RLock()
	defer fake.imageTagMutex.RUnlock()
	return len(fake.imageTagArgsForCall)
}

func (fake *FakeDockerClient) ImageTagArgsForCall(i int) (context.Context, string, string) {
	fake.imageTagMutex.RLock()
	defer fake.imageTagMutex.RUnlock()
	return fake.imageTagArgsForCall[i].ctx, fake.imageTagArgsForCall[i].image, fake.imageTagArgsForCall[i].ref
}

func (fake *FakeDockerClient) ImageTagReturns(result1 error) {
	fake.ImageTagStub = nil
	fake.imageTagReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDockerClient) ImageTagReturnsOnCall(i int, result1 error) {
	fake.ImageTagStub = nil
	if fake.imageTagReturnsOnCall == nil {
		fake.imageTagReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.imageTagReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDockerClient) ImagesPrune(ctx context.Context, pruneFilter filters.Args) (types.ImagesPruneReport, error) {
	fake.imagesPruneMutex.Lock()
	ret, specificReturn := fake.imagesPruneReturnsOnCall[len(fake.imagesPruneArgsForCall)]
	fake.imagesPruneArgsForCall = append(fake.imagesPruneArgsForCall, struct {
		ctx         context.Context
		pruneFilter filters.Args
	}{ctx, pruneFilter})
	fake.recordInvocation("ImagesPrune", []interface{}{ctx, pruneFilter})
	fake.imagesPruneMutex.Unlock()
	if fake.ImagesPruneStub != nil {
		return fake.ImagesPruneStub(ctx, pruneFilter)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.imagesPruneReturns.result1, fake.imagesPruneReturns.result2
}

func (fake *FakeDockerClient) ImagesPruneCallCount() int {
	fake.imagesPruneMutex.RLock()
	defer fake.imagesPruneMutex.RUnlock()
	return len(fake.imagesPruneArgsForCall)
}

func (fake *FakeDockerClient) ImagesPruneArgsForCall(i int) (context.Context, filters.Args) {
	fake.imagesPruneMutex.RLock()
	defer fake.imagesPruneMutex.RUnlock()
	return fake.imagesPruneArgsForCall[i].ctx, fake.imagesPruneArgsForCall[i].pruneFilter
}

func (fake *FakeDockerClient) ImagesPruneReturns(result1 types.ImagesPruneReport, result2 error) {
	fake.ImagesPruneStub = nil
	fake.imagesPruneReturns = struct {
		result1 types.ImagesPruneReport
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerClient) ImagesPruneReturnsOnCall(i int, result1 types.ImagesPruneReport, result2 error) {
	fake.ImagesPruneStub = nil
	if fake.imagesPruneReturnsOnCall == nil {
		fake.imagesPruneReturnsOnCall = make(map[int]struct {
			result1 types.ImagesPruneReport
			result2 error
		})
	}
	fake.imagesPruneReturnsOnCall[i] = struct {
		result1 types.ImagesPruneReport
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerClient) ContainerAttach(ctx context.Context, container string, options types.ContainerAttachOptions) (types.HijackedResponse, error) {
	fake.containerAttachMutex.Lock()
	ret, specificReturn := fake.containerAttachReturnsOnCall[len(fake.containerAttachArgsForCall)]
	fake.containerAttachArgsForCall = append(fake.containerAttachArgsForCall, struct {
		ctx       context.Context
		container string
		options   types.ContainerAttachOptions
	}{ctx, container, options})
	fake.recordInvocation("ContainerAttach", []interface{}{ctx, container, options})
	fake.containerAttachMutex.Unlock()
	if fake.ContainerAttachStub != nil {
		return fake.ContainerAttachStub(ctx, container, options)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.containerAttachReturns.result1, fake.containerAttachReturns.result2
}

func (fake *FakeDockerClient) ContainerAttachCallCount() int {
	fake.containerAttachMutex.RLock()
	defer fake.containerAttachMutex.RUnlock()
	return len(fake.containerAttachArgsForCall)
}

func (fake *FakeDockerClient) ContainerAttachArgsForCall(i int) (context.Context, string, types.ContainerAttachOptions) {
	fake.containerAttachMutex.RLock()
	defer fake.containerAttachMutex.RUnlock()
	return fake.containerAttachArgsForCall[i].ctx, fake.containerAttachArgsForCall[i].container, fake.containerAttachArgsForCall[i].options
}

func (fake *FakeDockerClient) ContainerAttachReturns(result1 types.HijackedResponse, result2 error) {
	fake.ContainerAttachStub = nil
	fake.containerAttachReturns = struct {
		result1 types.HijackedResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerClient) ContainerAttachReturnsOnCall(i int, result1 types.HijackedResponse, result2 error) {
	fake.ContainerAttachStub = nil
	if fake.containerAttachReturnsOnCall == nil {
		fake.containerAttachReturnsOnCall = make(map[int]struct {
			result1 types.HijackedResponse
			result2 error
		})
	}
	fake.containerAttachReturnsOnCall[i] = struct {
		result1 types.HijackedResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerClient) ContainerCommit(ctx context.Context, container string, options types.ContainerCommitOptions) (types.IDResponse, error) {
	fake.containerCommitMutex.Lock()
	ret, specificReturn := fake.containerCommitReturnsOnCall[len(fake.containerCommitArgsForCall)]
	fake.containerCommitArgsForCall = append(fake.containerCommitArgsForCall, struct {
		ctx       context.Context
		container string
		options   types.ContainerCommitOptions
	}{ctx, container, options})
	fake.recordInvocation("ContainerCommit", []interface{}{ctx, container, options})
	fake.containerCommitMutex.Unlock()
	if fake.ContainerCommitStub != nil {
		return fake.ContainerCommitStub(ctx, container, options)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.containerCommitReturns.result1, fake.containerCommitReturns.result2
}

func (fake *FakeDockerClient) ContainerCommitCallCount() int {
	fake.containerCommitMutex.RLock()
	defer fake.containerCommitMutex.RUnlock()
	return len(fake.containerCommitArgsForCall)
}

func (fake *FakeDockerClient) ContainerCommitArgsForCall(i int) (context.Context, string, types.ContainerCommitOptions) {
	fake.containerCommitMutex.RLock()
	defer fake.containerCommitMutex.RUnlock()
	return fake.containerCommitArgsForCall[i].ctx, fake.containerCommitArgsForCall[i].container, fake.containerCommitArgsForCall[i].options
}

func (fake *FakeDockerClient) ContainerCommitReturns(result1 types.IDResponse, result2 error) {
	fake.ContainerCommitStub = nil
	fake.containerCommitReturns = struct {
		result1 types.IDResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerClient) ContainerCommitReturnsOnCall(i int, result1 types.IDResponse, result2 error) {
	fake.ContainerCommitStub = nil
	if fake.containerCommitReturnsOnCall == nil {
		fake.containerCommitReturnsOnCall = make(map[int]struct {
			result1 types.IDResponse
			result2 error
		})
	}
	fake.containerCommitReturnsOnCall[i] = struct {
		result1 types.IDResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerClient) ContainerCreate(ctx context.Context, config *container.Config, hostConfig *container.HostConfig, networkingConfig *network.NetworkingConfig, containerName string) (container.ContainerCreateCreatedBody, error) {
	fake.containerCreateMutex.Lock()
	ret, specificReturn := fake.containerCreateReturnsOnCall[len(fake.containerCreateArgsForCall)]
	fake.containerCreateArgsForCall = append(fake.containerCreateArgsForCall, struct {
		ctx              context.Context
		config           *container.Config
		hostConfig       *container.HostConfig
		networkingConfig *network.NetworkingConfig
		containerName    string
	}{ctx, config, hostConfig, networkingConfig, containerName})
	fake.recordInvocation("ContainerCreate", []interface{}{ctx, config, hostConfig, networkingConfig, containerName})
	fake.containerCreateMutex.Unlock()
	if fake.ContainerCreateStub != nil {
		return fake.ContainerCreateStub(ctx, config, hostConfig, networkingConfig, containerName)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.containerCreateReturns.result1, fake.containerCreateReturns.result2
}

func (fake *FakeDockerClient) ContainerCreateCallCount() int {
	fake.containerCreateMutex.RLock()
	defer fake.containerCreateMutex.RUnlock()
	return len(fake.containerCreateArgsForCall)
}

func (fake *FakeDockerClient) ContainerCreateArgsForCall(i int) (context.Context, *container.Config, *container.HostConfig, *network.NetworkingConfig, string) {
	fake.containerCreateMutex.RLock()
	defer fake.containerCreateMutex.RUnlock()
	return fake.containerCreateArgsForCall[i].ctx, fake.containerCreateArgsForCall[i].config, fake.containerCreateArgsForCall[i].hostConfig, fake.containerCreateArgsForCall[i].networkingConfig, fake.containerCreateArgsForCall[i].containerName
}

func (fake *FakeDockerClient) ContainerCreateReturns(result1 container.ContainerCreateCreatedBody, result2 error) {
	fake.ContainerCreateStub = nil
	fake.containerCreateReturns = struct {
		result1 container.ContainerCreateCreatedBody
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerClient) ContainerCreateReturnsOnCall(i int, result1 container.ContainerCreateCreatedBody, result2 error) {
	fake.ContainerCreateStub = nil
	if fake.containerCreateReturnsOnCall == nil {
		fake.containerCreateReturnsOnCall = make(map[int]struct {
			result1 container.ContainerCreateCreatedBody
			result2 error
		})
	}
	fake.containerCreateReturnsOnCall[i] = struct {
		result1 container.ContainerCreateCreatedBody
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerClient) ContainerDiff(ctx context.Context, container string) ([]types.ContainerChange, error) {
	fake.containerDiffMutex.Lock()
	ret, specificReturn := fake.containerDiffReturnsOnCall[len(fake.containerDiffArgsForCall)]
	fake.containerDiffArgsForCall = append(fake.containerDiffArgsForCall, struct {
		ctx       context.Context
		container string
	}{ctx, container})
	fake.recordInvocation("ContainerDiff", []interface{}{ctx, container})
	fake.containerDiffMutex.Unlock()
	if fake.ContainerDiffStub != nil {
		return fake.ContainerDiffStub(ctx, container)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.containerDiffReturns.result1, fake.containerDiffReturns.result2
}

func (fake *FakeDockerClient) ContainerDiffCallCount() int {
	fake.containerDiffMutex.RLock()
	defer fake.containerDiffMutex.RUnlock()
	return len(fake.containerDiffArgsForCall)
}

func (fake *FakeDockerClient) ContainerDiffArgsForCall(i int) (context.Context, string) {
	fake.containerDiffMutex.RLock()
	defer fake.containerDiffMutex.RUnlock()
	return fake.containerDiffArgsForCall[i].ctx, fake.containerDiffArgsForCall[i].container
}

func (fake *FakeDockerClient) ContainerDiffReturns(result1 []types.ContainerChange, result2 error) {
	fake.ContainerDiffStub = nil
	fake.containerDiffReturns = struct {
		result1 []types.ContainerChange
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerClient) ContainerDiffReturnsOnCall(i int, result1 []types.ContainerChange, result2 error) {
	fake.ContainerDiffStub = nil
	if fake.containerDiffReturnsOnCall == nil {
		fake.containerDiffReturnsOnCall = make(map[int]struct {
			result1 []types.ContainerChange
			result2 error
		})
	}
	fake.containerDiffReturnsOnCall[i] = struct {
		result1 []types.ContainerChange
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerClient) ContainerExecAttach(ctx context.Context, execID string, config types.ExecConfig) (types.HijackedResponse, error) {
	fake.containerExecAttachMutex.Lock()
	ret, specificReturn := fake.containerExecAttachReturnsOnCall[len(fake.containerExecAttachArgsForCall)]
	fake.containerExecAttachArgsForCall = append(fake.containerExecAttachArgsForCall, struct {
		ctx    context.Context
		execID string
		config types.ExecConfig
	}{ctx, execID, config})
	fake.recordInvocation("ContainerExecAttach", []interface{}{ctx, execID, config})
	fake.containerExecAttachMutex.Unlock()
	if fake.ContainerExecAttachStub != nil {
		return fake.ContainerExecAttachStub(ctx, execID, config)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.containerExecAttachReturns.result1, fake.containerExecAttachReturns.result2
}

func (fake *FakeDockerClient) ContainerExecAttachCallCount() int {
	fake.containerExecAttachMutex.RLock()
	defer fake.containerExecAttachMutex.RUnlock()
	return len(fake.containerExecAttachArgsForCall)
}

func (fake *FakeDockerClient) ContainerExecAttachArgsForCall(i int) (context.Context, string, types.ExecConfig) {
	fake.containerExecAttachMutex.RLock()
	defer fake.containerExecAttachMutex.RUnlock()
	return fake.containerExecAttachArgsForCall[i].ctx, fake.containerExecAttachArgsForCall[i].execID, fake.containerExecAttachArgsForCall[i].config
}

func (fake *FakeDockerClient) ContainerExecAttachReturns(result1 types.HijackedResponse, result2 error) {
	fake.ContainerExecAttachStub = nil
	fake.containerExecAttachReturns = struct {
		result1 types.HijackedResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerClient) ContainerExecAttachReturnsOnCall(i int, result1 types.HijackedResponse, result2 error) {
	fake.ContainerExecAttachStub = nil
	if fake.containerExecAttachReturnsOnCall == nil {
		fake.containerExecAttachReturnsOnCall = make(map[int]struct {
			result1 types.HijackedResponse
			result2 error
		})
	}
	fake.containerExecAttachReturnsOnCall[i] = struct {
		result1 types.HijackedResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerClient) ContainerExecCreate(ctx context.Context, container string, config types.ExecConfig) (types.IDResponse, error) {
	fake.containerExecCreateMutex.Lock()
	ret, specificReturn := fake.containerExecCreateReturnsOnCall[len(fake.containerExecCreateArgsForCall)]
	fake.containerExecCreateArgsForCall = append(fake.containerExecCreateArgsForCall, struct {
		ctx       context.Context
		container string
		config    types.ExecConfig
	}{ctx, container, config})
	fake.recordInvocation("ContainerExecCreate", []interface{}{ctx, container, config})
	fake.containerExecCreateMutex.Unlock()
	if fake.ContainerExecCreateStub != nil {
		return fake.ContainerExecCreateStub(ctx, container, config)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.containerExecCreateReturns.result1, fake.containerExecCreateReturns.result2
}

func (fake *FakeDockerClient) ContainerExecCreateCallCount() int {
	fake.containerExecCreateMutex.RLock()
	defer fake.containerExecCreateMutex.RUnlock()
	return len(fake.containerExecCreateArgsForCall)
}

func (fake *FakeDockerClient) ContainerExecCreateArgsForCall(i int) (context.Context, string, types.ExecConfig) {
	fake.containerExecCreateMutex.RLock()
	defer fake.containerExecCreateMutex.RUnlock()
	return fake.containerExecCreateArgsForCall[i].ctx, fake.containerExecCreateArgsForCall[i].container, fake.containerExecCreateArgsForCall[i].config
}

func (fake *FakeDockerClient) ContainerExecCreateReturns(result1 types.IDResponse, result2 error) {
	fake.ContainerExecCreateStub = nil
	fake.containerExecCreateReturns = struct {
		result1 types.IDResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerClient) ContainerExecCreateReturnsOnCall(i int, result1 types.IDResponse, result2 error) {
	fake.ContainerExecCreateStub = nil
	if fake.containerExecCreateReturnsOnCall == nil {
		fake.containerExecCreateReturnsOnCall = make(map[int]struct {
			result1 types.IDResponse
			result2 error
		})
	}
	fake.containerExecCreateReturnsOnCall[i] = struct {
		result1 types.IDResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerClient) ContainerExecInspect(ctx context.Context, execID string) (types.ContainerExecInspect, error) {
	fake.containerExecInspectMutex.Lock()
	ret, specificReturn := fake.containerExecInspectReturnsOnCall[len(fake.containerExecInspectArgsForCall)]
	fake.containerExecInspectArgsForCall = append(fake.containerExecInspectArgsForCall, struct {
		ctx    context.Context
		execID string
	}{ctx, execID})
	fake.recordInvocation("ContainerExecInspect", []interface{}{ctx, execID})
	fake.containerExecInspectMutex.Unlock()
	if fake.ContainerExecInspectStub != nil {
		return fake.ContainerExecInspectStub(ctx, execID)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.containerExecInspectReturns.result1, fake.containerExecInspectReturns.result2
}

func (fake *FakeDockerClient) ContainerExecInspectCallCount() int {
	fake.containerExecInspectMutex.RLock()
	defer fake.containerExecInspectMutex.RUnlock()
	return len(fake.containerExecInspectArgsForCall)
}

func (fake *FakeDockerClient) ContainerExecInspectArgsForCall(i int) (context.Context, string) {
	fake.containerExecInspectMutex.RLock()
	defer fake.containerExecInspectMutex.RUnlock()
	return fake.containerExecInspectArgsForCall[i].ctx, fake.containerExecInspectArgsForCall[i].execID
}

func (fake *FakeDockerClient) ContainerExecInspectReturns(result1 types.ContainerExecInspect, result2 error) {
	fake.ContainerExecInspectStub = nil
	fake.containerExecInspectReturns = struct {
		result1 types.ContainerExecInspect
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerClient) ContainerExecInspectReturnsOnCall(i int, result1 types.ContainerExecInspect, result2 error) {
	fake.ContainerExecInspectStub = nil
	if fake.containerExecInspectReturnsOnCall == nil {
		fake.containerExecInspectReturnsOnCall = make(map[int]struct {
			result1 types.ContainerExecInspect
			result2 error
		})
	}
	fake.containerExecInspectReturnsOnCall[i] = struct {
		result1 types.ContainerExecInspect
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerClient) ContainerExecResize(ctx context.Context, execID string, options types.ResizeOptions) error {
	fake.containerExecResizeMutex.Lock()
	ret, specificReturn := fake.containerExecResizeReturnsOnCall[len(fake.containerExecResizeArgsForCall)]
	fake.containerExecResizeArgsForCall = append(fake.containerExecResizeArgsForCall, struct {
		ctx     context.Context
		execID  string
		options types.ResizeOptions
	}{ctx, execID, options})
	fake.recordInvocation("ContainerExecResize", []interface{}{ctx, execID, options})
	fake.containerExecResizeMutex.Unlock()
	if fake.ContainerExecResizeStub != nil {
		return fake.ContainerExecResizeStub(ctx, execID, options)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.containerExecResizeReturns.result1
}

func (fake *FakeDockerClient) ContainerExecResizeCallCount() int {
	fake.containerExecResizeMutex.RLock()
	defer fake.containerExecResizeMutex.RUnlock()
	return len(fake.containerExecResizeArgsForCall)
}

func (fake *FakeDockerClient) ContainerExecResizeArgsForCall(i int) (context.Context, string, types.ResizeOptions) {
	fake.containerExecResizeMutex.RLock()
	defer fake.containerExecResizeMutex.RUnlock()
	return fake.containerExecResizeArgsForCall[i].ctx, fake.containerExecResizeArgsForCall[i].execID, fake.containerExecResizeArgsForCall[i].options
}

func (fake *FakeDockerClient) ContainerExecResizeReturns(result1 error) {
	fake.ContainerExecResizeStub = nil
	fake.containerExecResizeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDockerClient) ContainerExecResizeReturnsOnCall(i int, result1 error) {
	fake.ContainerExecResizeStub = nil
	if fake.containerExecResizeReturnsOnCall == nil {
		fake.containerExecResizeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.containerExecResizeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDockerClient) ContainerExecStart(ctx context.Context, execID string, config types.ExecStartCheck) error {
	fake.containerExecStartMutex.Lock()
	ret, specificReturn := fake.containerExecStartReturnsOnCall[len(fake.containerExecStartArgsForCall)]
	fake.containerExecStartArgsForCall = append(fake.containerExecStartArgsForCall, struct {
		ctx    context.Context
		execID string
		config types.ExecStartCheck
	}{ctx, execID, config})
	fake.recordInvocation("ContainerExecStart", []interface{}{ctx, execID, config})
	fake.containerExecStartMutex.Unlock()
	if fake.ContainerExecStartStub != nil {
		return fake.ContainerExecStartStub(ctx, execID, config)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.containerExecStartReturns.result1
}

func (fake *FakeDockerClient) ContainerExecStartCallCount() int {
	fake.containerExecStartMutex.RLock()
	defer fake.containerExecStartMutex.RUnlock()
	return len(fake.containerExecStartArgsForCall)
}

func (fake *FakeDockerClient) ContainerExecStartArgsForCall(i int) (context.Context, string, types.ExecStartCheck) {
	fake.containerExecStartMutex.RLock()
	defer fake.containerExecStartMutex.RUnlock()
	return fake.containerExecStartArgsForCall[i].ctx, fake.containerExecStartArgsForCall[i].execID, fake.containerExecStartArgsForCall[i].config
}

func (fake *FakeDockerClient) ContainerExecStartReturns(result1 error) {
	fake.ContainerExecStartStub = nil
	fake.containerExecStartReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDockerClient) ContainerExecStartReturnsOnCall(i int, result1 error) {
	fake.ContainerExecStartStub = nil
	if fake.containerExecStartReturnsOnCall == nil {
		fake.containerExecStartReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.containerExecStartReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDockerClient) ContainerExport(ctx context.Context, container string) (io.ReadCloser, error) {
	fake.containerExportMutex.Lock()
	ret, specificReturn := fake.containerExportReturnsOnCall[len(fake.containerExportArgsForCall)]
	fake.containerExportArgsForCall = append(fake.containerExportArgsForCall, struct {
		ctx       context.Context
		container string
	}{ctx, container})
	fake.recordInvocation("ContainerExport", []interface{}{ctx, container})
	fake.containerExportMutex.Unlock()
	if fake.ContainerExportStub != nil {
		return fake.ContainerExportStub(ctx, container)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.containerExportReturns.result1, fake.containerExportReturns.result2
}

func (fake *FakeDockerClient) ContainerExportCallCount() int {
	fake.containerExportMutex.RLock()
	defer fake.containerExportMutex.RUnlock()
	return len(fake.containerExportArgsForCall)
}

func (fake *FakeDockerClient) ContainerExportArgsForCall(i int) (context.Context, string) {
	fake.containerExportMutex.RLock()
	defer fake.containerExportMutex.RUnlock()
	return fake.containerExportArgsForCall[i].ctx, fake.containerExportArgsForCall[i].container
}

func (fake *FakeDockerClient) ContainerExportReturns(result1 io.ReadCloser, result2 error) {
	fake.ContainerExportStub = nil
	fake.containerExportReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerClient) ContainerExportReturnsOnCall(i int, result1 io.ReadCloser, result2 error) {
	fake.ContainerExportStub = nil
	if fake.containerExportReturnsOnCall == nil {
		fake.containerExportReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 error
		})
	}
	fake.containerExportReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerClient) ContainerInspect(ctx context.Context, container string) (types.ContainerJSON, error) {
	fake.containerInspectMutex.Lock()
	ret, specificReturn := fake.containerInspectReturnsOnCall[len(fake.containerInspectArgsForCall)]
	fake.containerInspectArgsForCall = append(fake.containerInspectArgsForCall, struct {
		ctx       context.Context
		container string
	}{ctx, container})
	fake.recordInvocation("ContainerInspect", []interface{}{ctx, container})
	fake.containerInspectMutex.Unlock()
	if fake.ContainerInspectStub != nil {
		return fake.ContainerInspectStub(ctx, container)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.containerInspectReturns.result1, fake.containerInspectReturns.result2
}

func (fake *FakeDockerClient) ContainerInspectCallCount() int {
	fake.containerInspectMutex.RLock()
	defer fake.containerInspectMutex.RUnlock()
	return len(fake.containerInspectArgsForCall)
}

func (fake *FakeDockerClient) ContainerInspectArgsForCall(i int) (context.Context, string) {
	fake.containerInspectMutex.RLock()
	defer fake.containerInspectMutex.RUnlock()
	return fake.containerInspectArgsForCall[i].ctx, fake.containerInspectArgsForCall[i].container
}

func (fake *FakeDockerClient) ContainerInspectReturns(result1 types.ContainerJSON, result2 error) {
	fake.ContainerInspectStub = nil
	fake.containerInspectReturns = struct {
		result1 types.ContainerJSON
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerClient) ContainerInspectReturnsOnCall(i int, result1 types.ContainerJSON, result2 error) {
	fake.ContainerInspectStub = nil
	if fake.containerInspectReturnsOnCall == nil {
		fake.containerInspectReturnsOnCall = make(map[int]struct {
			result1 types.ContainerJSON
			result2 error
		})
	}
	fake.containerInspectReturnsOnCall[i] = struct {
		result1 types.ContainerJSON
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerClient) ContainerInspectWithRaw(ctx context.Context, container string, getSize bool) (types.ContainerJSON, []byte, error) {
	fake.containerInspectWithRawMutex.Lock()
	ret, specificReturn := fake.containerInspectWithRawReturnsOnCall[len(fake.containerInspectWithRawArgsForCall)]
	fake.containerInspectWithRawArgsForCall = append(fake.containerInspectWithRawArgsForCall, struct {
		ctx       context.Context
		container string
		getSize   bool
	}{ctx, container, getSize})
	fake.recordInvocation("ContainerInspectWithRaw", []interface{}{ctx, container, getSize})
	fake.containerInspectWithRawMutex.Unlock()
	if fake.ContainerInspectWithRawStub != nil {
		return fake.ContainerInspectWithRawStub(ctx, container, getSize)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.containerInspectWithRawReturns.result1, fake.containerInspectWithRawReturns.result2, fake.containerInspectWithRawReturns.result3
}

func (fake *FakeDockerClient) ContainerInspectWithRawCallCount() int {
	fake.containerInspectWithRawMutex.RLock()
	defer fake.containerInspectWithRawMutex.RUnlock()
	return len(fake.containerInspectWithRawArgsForCall)
}

func (fake *FakeDockerClient) ContainerInspectWithRawArgsForCall(i int) (context.Context, string, bool) {
	fake.containerInspectWithRawMutex.RLock()
	defer fake.containerInspectWithRawMutex.RUnlock()
	return fake.containerInspectWithRawArgsForCall[i].ctx, fake.containerInspectWithRawArgsForCall[i].container, fake.containerInspectWithRawArgsForCall[i].getSize
}

func (fake *FakeDockerClient) ContainerInspectWithRawReturns(result1 types.ContainerJSON, result2 []byte, result3 error) {
	fake.ContainerInspectWithRawStub = nil
	fake.containerInspectWithRawReturns = struct {
		result1 types.ContainerJSON
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDockerClient) ContainerInspectWithRawReturnsOnCall(i int, result1 types.ContainerJSON, result2 []byte, result3 error) {
	fake.ContainerInspectWithRawStub = nil
	if fake.containerInspectWithRawReturnsOnCall == nil {
		fake.containerInspectWithRawReturnsOnCall = make(map[int]struct {
			result1 types.ContainerJSON
			result2 []byte
			result3 error
		})
	}
	fake.containerInspectWithRawReturnsOnCall[i] = struct {
		result1 types.ContainerJSON
		result2 []byte
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDockerClient) ContainerKill(ctx context.Context, container string, signal string) error {
	fake.containerKillMutex.Lock()
	ret, specificReturn := fake.containerKillReturnsOnCall[len(fake.containerKillArgsForCall)]
	fake.containerKillArgsForCall = append(fake.containerKillArgsForCall, struct {
		ctx       context.Context
		container string
		signal    string
	}{ctx, container, signal})
	fake.recordInvocation("ContainerKill", []interface{}{ctx, container, signal})
	fake.containerKillMutex.Unlock()
	if fake.ContainerKillStub != nil {
		return fake.ContainerKillStub(ctx, container, signal)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.containerKillReturns.result1
}

func (fake *FakeDockerClient) ContainerKillCallCount() int {
	fake.containerKillMutex.RLock()
	defer fake.containerKillMutex.RUnlock()
	return len(fake.containerKillArgsForCall)
}

func (fake *FakeDockerClient) ContainerKillArgsForCall(i int) (context.Context, string, string) {
	fake.containerKillMutex.RLock()
	defer fake.containerKillMutex.RUnlock()
	return fake.containerKillArgsForCall[i].ctx, fake.containerKillArgsForCall[i].container, fake.containerKillArgsForCall[i].signal
}

func (fake *FakeDockerClient) ContainerKillReturns(result1 error) {
	fake.ContainerKillStub = nil
	fake.containerKillReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDockerClient) ContainerKillReturnsOnCall(i int, result1 error) {
	fake.ContainerKillStub = nil
	if fake.containerKillReturnsOnCall == nil {
		fake.containerKillReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.containerKillReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDockerClient) ContainerList(ctx context.Context, options types.ContainerListOptions) ([]types.Container, error) {
	fake.containerListMutex.Lock()
	ret, specificReturn := fake.containerListReturnsOnCall[len(fake.containerListArgsForCall)]
	fake.containerListArgsForCall = append(fake.containerListArgsForCall, struct {
		ctx     context.Context
		options types.ContainerListOptions
	}{ctx, options})
	fake.recordInvocation("ContainerList", []interface{}{ctx, options})
	fake.containerListMutex.Unlock()
	if fake.ContainerListStub != nil {
		return fake.ContainerListStub(ctx, options)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.containerListReturns.result1, fake.containerListReturns.result2
}

func (fake *FakeDockerClient) ContainerListCallCount() int {
	fake.containerListMutex.RLock()
	defer fake.containerListMutex.RUnlock()
	return len(fake.containerListArgsForCall)
}

func (fake *FakeDockerClient) ContainerListArgsForCall(i int) (context.Context, types.ContainerListOptions) {
	fake.containerListMutex.RLock()
	defer fake.containerListMutex.RUnlock()
	return fake.containerListArgsForCall[i].ctx, fake.containerListArgsForCall[i].options
}

func (fake *FakeDockerClient) ContainerListReturns(result1 []types.Container, result2 error) {
	fake.ContainerListStub = nil
	fake.containerListReturns = struct {
		result1 []types.Container
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerClient) ContainerListReturnsOnCall(i int, result1 []types.Container, result2 error) {
	fake.ContainerListStub = nil
	if fake.containerListReturnsOnCall == nil {
		fake.containerListReturnsOnCall = make(map[int]struct {
			result1 []types.Container
			result2 error
		})
	}
	fake.containerListReturnsOnCall[i] = struct {
		result1 []types.Container
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerClient) ContainerLogs(ctx context.Context, container string, options types.ContainerLogsOptions) (io.ReadCloser, error) {
	fake.containerLogsMutex.Lock()
	ret, specificReturn := fake.containerLogsReturnsOnCall[len(fake.containerLogsArgsForCall)]
	fake.containerLogsArgsForCall = append(fake.containerLogsArgsForCall, struct {
		ctx       context.Context
		container string
		options   types.ContainerLogsOptions
	}{ctx, container, options})
	fake.recordInvocation("ContainerLogs", []interface{}{ctx, container, options})
	fake.containerLogsMutex.Unlock()
	if fake.ContainerLogsStub != nil {
		return fake.ContainerLogsStub(ctx, container, options)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.containerLogsReturns.result1, fake.containerLogsReturns.result2
}

func (fake *FakeDockerClient) ContainerLogsCallCount() int {
	fake.containerLogsMutex.RLock()
	defer fake.containerLogsMutex.RUnlock()
	return len(fake.containerLogsArgsForCall)
}

func (fake *FakeDockerClient) ContainerLogsArgsForCall(i int) (context.Context, string, types.ContainerLogsOptions) {
	fake.containerLogsMutex.RLock()
	defer fake.containerLogsMutex.RUnlock()
	return fake.containerLogsArgsForCall[i].ctx, fake.containerLogsArgsForCall[i].container, fake.containerLogsArgsForCall[i].options
}

func (fake *FakeDockerClient) ContainerLogsReturns(result1 io.ReadCloser, result2 error) {
	fake.ContainerLogsStub = nil
	fake.containerLogsReturns = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerClient) ContainerLogsReturnsOnCall(i int, result1 io.ReadCloser, result2 error) {
	fake.ContainerLogsStub = nil
	if fake.containerLogsReturnsOnCall == nil {
		fake.containerLogsReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 error
		})
	}
	fake.containerLogsReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerClient) ContainerPause(ctx context.Context, container string) error {
	fake.containerPauseMutex.Lock()
	ret, specificReturn := fake.containerPauseReturnsOnCall[len(fake.containerPauseArgsForCall)]
	fake.containerPauseArgsForCall = append(fake.containerPauseArgsForCall, struct {
		ctx       context.Context
		container string
	}{ctx, container})
	fake.recordInvocation("ContainerPause", []interface{}{ctx, container})
	fake.containerPauseMutex.Unlock()
	if fake.ContainerPauseStub != nil {
		return fake.ContainerPauseStub(ctx, container)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.containerPauseReturns.result1
}

func (fake *FakeDockerClient) ContainerPauseCallCount() int {
	fake.containerPauseMutex.RLock()
	defer fake.containerPauseMutex.RUnlock()
	return len(fake.containerPauseArgsForCall)
}

func (fake *FakeDockerClient) ContainerPauseArgsForCall(i int) (context.Context, string) {
	fake.containerPauseMutex.RLock()
	defer fake.containerPauseMutex.RUnlock()
	return fake.containerPauseArgsForCall[i].ctx, fake.containerPauseArgsForCall[i].container
}

func (fake *FakeDockerClient) ContainerPauseReturns(result1 error) {
	fake.ContainerPauseStub = nil
	fake.containerPauseReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDockerClient) ContainerPauseReturnsOnCall(i int, result1 error) {
	fake.ContainerPauseStub = nil
	if fake.containerPauseReturnsOnCall == nil {
		fake.containerPauseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.containerPauseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDockerClient) ContainerRemove(ctx context.Context, container string, options types.ContainerRemoveOptions) error {
	fake.containerRemoveMutex.Lock()
	ret, specificReturn := fake.containerRemoveReturnsOnCall[len(fake.containerRemoveArgsForCall)]
	fake.containerRemoveArgsForCall = append(fake.containerRemoveArgsForCall, struct {
		ctx       context.Context
		container string
		options   types.ContainerRemoveOptions
	}{ctx, container, options})
	fake.recordInvocation("ContainerRemove", []interface{}{ctx, container, options})
	fake.containerRemoveMutex.Unlock()
	if fake.ContainerRemoveStub != nil {
		return fake.ContainerRemoveStub(ctx, container, options)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.containerRemoveReturns.result1
}

func (fake *FakeDockerClient) ContainerRemoveCallCount() int {
	fake.containerRemoveMutex.RLock()
	defer fake.containerRemoveMutex.RUnlock()
	return len(fake.containerRemoveArgsForCall)
}

func (fake *FakeDockerClient) ContainerRemoveArgsForCall(i int) (context.Context, string, types.ContainerRemoveOptions) {
	fake.containerRemoveMutex.RLock()
	defer fake.containerRemoveMutex.RUnlock()
	return fake.containerRemoveArgsForCall[i].ctx, fake.containerRemoveArgsForCall[i].container, fake.containerRemoveArgsForCall[i].options
}

func (fake *FakeDockerClient) ContainerRemoveReturns(result1 error) {
	fake.ContainerRemoveStub = nil
	fake.containerRemoveReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDockerClient) ContainerRemoveReturnsOnCall(i int, result1 error) {
	fake.ContainerRemoveStub = nil
	if fake.containerRemoveReturnsOnCall == nil {
		fake.containerRemoveReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.containerRemoveReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDockerClient) ContainerRename(ctx context.Context, container string, newContainerName string) error {
	fake.containerRenameMutex.Lock()
	ret, specificReturn := fake.containerRenameReturnsOnCall[len(fake.containerRenameArgsForCall)]
	fake.containerRenameArgsForCall = append(fake.containerRenameArgsForCall, struct {
		ctx              context.Context
		container        string
		newContainerName string
	}{ctx, container, newContainerName})
	fake.recordInvocation("ContainerRename", []interface{}{ctx, container, newContainerName})
	fake.containerRenameMutex.Unlock()
	if fake.ContainerRenameStub != nil {
		return fake.ContainerRenameStub(ctx, container, newContainerName)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.containerRenameReturns.result1
}

func (fake *FakeDockerClient) ContainerRenameCallCount() int {
	fake.containerRenameMutex.RLock()
	defer fake.containerRenameMutex.RUnlock()
	return len(fake.containerRenameArgsForCall)
}

func (fake *FakeDockerClient) ContainerRenameArgsForCall(i int) (context.Context, string, string) {
	fake.containerRenameMutex.RLock()
	defer fake.containerRenameMutex.RUnlock()
	return fake.containerRenameArgsForCall[i].ctx, fake.containerRenameArgsForCall[i].container, fake.containerRenameArgsForCall[i].newContainerName
}

func (fake *FakeDockerClient) ContainerRenameReturns(result1 error) {
	fake.ContainerRenameStub = nil
	fake.containerRenameReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDockerClient) ContainerRenameReturnsOnCall(i int, result1 error) {
	fake.ContainerRenameStub = nil
	if fake.containerRenameReturnsOnCall == nil {
		fake.containerRenameReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.containerRenameReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDockerClient) ContainerResize(ctx context.Context, container string, options types.ResizeOptions) error {
	fake.containerResizeMutex.Lock()
	ret, specificReturn := fake.containerResizeReturnsOnCall[len(fake.containerResizeArgsForCall)]
	fake.containerResizeArgsForCall = append(fake.containerResizeArgsForCall, struct {
		ctx       context.Context
		container string
		options   types.ResizeOptions
	}{ctx, container, options})
	fake.recordInvocation("ContainerResize", []interface{}{ctx, container, options})
	fake.containerResizeMutex.Unlock()
	if fake.ContainerResizeStub != nil {
		return fake.ContainerResizeStub(ctx, container, options)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.containerResizeReturns.result1
}

func (fake *FakeDockerClient) ContainerResizeCallCount() int {
	fake.containerResizeMutex.RLock()
	defer fake.containerResizeMutex.RUnlock()
	return len(fake.containerResizeArgsForCall)
}

func (fake *FakeDockerClient) ContainerResizeArgsForCall(i int) (context.Context, string, types.ResizeOptions) {
	fake.containerResizeMutex.RLock()
	defer fake.containerResizeMutex.RUnlock()
	return fake.containerResizeArgsForCall[i].ctx, fake.containerResizeArgsForCall[i].container, fake.containerResizeArgsForCall[i].options
}

func (fake *FakeDockerClient) ContainerResizeReturns(result1 error) {
	fake.ContainerResizeStub = nil
	fake.containerResizeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDockerClient) ContainerResizeReturnsOnCall(i int, result1 error) {
	fake.ContainerResizeStub = nil
	if fake.containerResizeReturnsOnCall == nil {
		fake.containerResizeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.containerResizeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDockerClient) ContainerRestart(ctx context.Context, container string, timeout *time.Duration) error {
	fake.containerRestartMutex.Lock()
	ret, specificReturn := fake.containerRestartReturnsOnCall[len(fake.containerRestartArgsForCall)]
	fake.containerRestartArgsForCall = append(fake.containerRestartArgsForCall, struct {
		ctx       context.Context
		container string
		timeout   *time.Duration
	}{ctx, container, timeout})
	fake.recordInvocation("ContainerRestart", []interface{}{ctx, container, timeout})
	fake.containerRestartMutex.Unlock()
	if fake.ContainerRestartStub != nil {
		return fake.ContainerRestartStub(ctx, container, timeout)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.containerRestartReturns.result1
}

func (fake *FakeDockerClient) ContainerRestartCallCount() int {
	fake.containerRestartMutex.RLock()
	defer fake.containerRestartMutex.RUnlock()
	return len(fake.containerRestartArgsForCall)
}

func (fake *FakeDockerClient) ContainerRestartArgsForCall(i int) (context.Context, string, *time.Duration) {
	fake.containerRestartMutex.RLock()
	defer fake.containerRestartMutex.RUnlock()
	return fake.containerRestartArgsForCall[i].ctx, fake.containerRestartArgsForCall[i].container, fake.containerRestartArgsForCall[i].timeout
}

func (fake *FakeDockerClient) ContainerRestartReturns(result1 error) {
	fake.ContainerRestartStub = nil
	fake.containerRestartReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDockerClient) ContainerRestartReturnsOnCall(i int, result1 error) {
	fake.ContainerRestartStub = nil
	if fake.containerRestartReturnsOnCall == nil {
		fake.containerRestartReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.containerRestartReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDockerClient) ContainerStatPath(ctx context.Context, container string, path string) (types.ContainerPathStat, error) {
	fake.containerStatPathMutex.Lock()
	ret, specificReturn := fake.containerStatPathReturnsOnCall[len(fake.containerStatPathArgsForCall)]
	fake.containerStatPathArgsForCall = append(fake.containerStatPathArgsForCall, struct {
		ctx       context.Context
		container string
		path      string
	}{ctx, container, path})
	fake.recordInvocation("ContainerStatPath", []interface{}{ctx, container, path})
	fake.containerStatPathMutex.Unlock()
	if fake.ContainerStatPathStub != nil {
		return fake.ContainerStatPathStub(ctx, container, path)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.containerStatPathReturns.result1, fake.containerStatPathReturns.result2
}

func (fake *FakeDockerClient) ContainerStatPathCallCount() int {
	fake.containerStatPathMutex.RLock()
	defer fake.containerStatPathMutex.RUnlock()
	return len(fake.containerStatPathArgsForCall)
}

func (fake *FakeDockerClient) ContainerStatPathArgsForCall(i int) (context.Context, string, string) {
	fake.containerStatPathMutex.RLock()
	defer fake.containerStatPathMutex.RUnlock()
	return fake.containerStatPathArgsForCall[i].ctx, fake.containerStatPathArgsForCall[i].container, fake.containerStatPathArgsForCall[i].path
}

func (fake *FakeDockerClient) ContainerStatPathReturns(result1 types.ContainerPathStat, result2 error) {
	fake.ContainerStatPathStub = nil
	fake.containerStatPathReturns = struct {
		result1 types.ContainerPathStat
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerClient) ContainerStatPathReturnsOnCall(i int, result1 types.ContainerPathStat, result2 error) {
	fake.ContainerStatPathStub = nil
	if fake.containerStatPathReturnsOnCall == nil {
		fake.containerStatPathReturnsOnCall = make(map[int]struct {
			result1 types.ContainerPathStat
			result2 error
		})
	}
	fake.containerStatPathReturnsOnCall[i] = struct {
		result1 types.ContainerPathStat
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerClient) ContainerStats(ctx context.Context, container string, stream bool) (types.ContainerStats, error) {
	fake.containerStatsMutex.Lock()
	ret, specificReturn := fake.containerStatsReturnsOnCall[len(fake.containerStatsArgsForCall)]
	fake.containerStatsArgsForCall = append(fake.containerStatsArgsForCall, struct {
		ctx       context.Context
		container string
		stream    bool
	}{ctx, container, stream})
	fake.recordInvocation("ContainerStats", []interface{}{ctx, container, stream})
	fake.containerStatsMutex.Unlock()
	if fake.ContainerStatsStub != nil {
		return fake.ContainerStatsStub(ctx, container, stream)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.containerStatsReturns.result1, fake.containerStatsReturns.result2
}

func (fake *FakeDockerClient) ContainerStatsCallCount() int {
	fake.containerStatsMutex.RLock()
	defer fake.containerStatsMutex.RUnlock()
	return len(fake.containerStatsArgsForCall)
}

func (fake *FakeDockerClient) ContainerStatsArgsForCall(i int) (context.Context, string, bool) {
	fake.containerStatsMutex.RLock()
	defer fake.containerStatsMutex.RUnlock()
	return fake.containerStatsArgsForCall[i].ctx, fake.containerStatsArgsForCall[i].container, fake.containerStatsArgsForCall[i].stream
}

func (fake *FakeDockerClient) ContainerStatsReturns(result1 types.ContainerStats, result2 error) {
	fake.ContainerStatsStub = nil
	fake.containerStatsReturns = struct {
		result1 types.ContainerStats
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerClient) ContainerStatsReturnsOnCall(i int, result1 types.ContainerStats, result2 error) {
	fake.ContainerStatsStub = nil
	if fake.containerStatsReturnsOnCall == nil {
		fake.containerStatsReturnsOnCall = make(map[int]struct {
			result1 types.ContainerStats
			result2 error
		})
	}
	fake.containerStatsReturnsOnCall[i] = struct {
		result1 types.ContainerStats
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerClient) ContainerStart(ctx context.Context, container string, options types.ContainerStartOptions) error {
	fake.containerStartMutex.Lock()
	ret, specificReturn := fake.containerStartReturnsOnCall[len(fake.containerStartArgsForCall)]
	fake.containerStartArgsForCall = append(fake.containerStartArgsForCall, struct {
		ctx       context.Context
		container string
		options   types.ContainerStartOptions
	}{ctx, container, options})
	fake.recordInvocation("ContainerStart", []interface{}{ctx, container, options})
	fake.containerStartMutex.Unlock()
	if fake.ContainerStartStub != nil {
		return fake.ContainerStartStub(ctx, container, options)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.containerStartReturns.result1
}

func (fake *FakeDockerClient) ContainerStartCallCount() int {
	fake.containerStartMutex.RLock()
	defer fake.containerStartMutex.RUnlock()
	return len(fake.containerStartArgsForCall)
}

func (fake *FakeDockerClient) ContainerStartArgsForCall(i int) (context.Context, string, types.ContainerStartOptions) {
	fake.containerStartMutex.RLock()
	defer fake.containerStartMutex.RUnlock()
	return fake.containerStartArgsForCall[i].ctx, fake.containerStartArgsForCall[i].container, fake.containerStartArgsForCall[i].options
}

func (fake *FakeDockerClient) ContainerStartReturns(result1 error) {
	fake.ContainerStartStub = nil
	fake.containerStartReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDockerClient) ContainerStartReturnsOnCall(i int, result1 error) {
	fake.ContainerStartStub = nil
	if fake.containerStartReturnsOnCall == nil {
		fake.containerStartReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.containerStartReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDockerClient) ContainerStop(ctx context.Context, container string, timeout *time.Duration) error {
	fake.containerStopMutex.Lock()
	ret, specificReturn := fake.containerStopReturnsOnCall[len(fake.containerStopArgsForCall)]
	fake.containerStopArgsForCall = append(fake.containerStopArgsForCall, struct {
		ctx       context.Context
		container string
		timeout   *time.Duration
	}{ctx, container, timeout})
	fake.recordInvocation("ContainerStop", []interface{}{ctx, container, timeout})
	fake.containerStopMutex.Unlock()
	if fake.ContainerStopStub != nil {
		return fake.ContainerStopStub(ctx, container, timeout)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.containerStopReturns.result1
}

func (fake *FakeDockerClient) ContainerStopCallCount() int {
	fake.containerStopMutex.RLock()
	defer fake.containerStopMutex.RUnlock()
	return len(fake.containerStopArgsForCall)
}

func (fake *FakeDockerClient) ContainerStopArgsForCall(i int) (context.Context, string, *time.Duration) {
	fake.containerStopMutex.RLock()
	defer fake.containerStopMutex.RUnlock()
	return fake.containerStopArgsForCall[i].ctx, fake.containerStopArgsForCall[i].container, fake.containerStopArgsForCall[i].timeout
}

func (fake *FakeDockerClient) ContainerStopReturns(result1 error) {
	fake.ContainerStopStub = nil
	fake.containerStopReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDockerClient) ContainerStopReturnsOnCall(i int, result1 error) {
	fake.ContainerStopStub = nil
	if fake.containerStopReturnsOnCall == nil {
		fake.containerStopReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.containerStopReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDockerClient) ContainerTop(ctx context.Context, container string, arguments []string) (types.ContainerProcessList, error) {
	var argumentsCopy []string
	if arguments != nil {
		argumentsCopy = make([]string, len(arguments))
		copy(argumentsCopy, arguments)
	}
	fake.containerTopMutex.Lock()
	ret, specificReturn := fake.containerTopReturnsOnCall[len(fake.containerTopArgsForCall)]
	fake.containerTopArgsForCall = append(fake.containerTopArgsForCall, struct {
		ctx       context.Context
		container string
		arguments []string
	}{ctx, container, argumentsCopy})
	fake.recordInvocation("ContainerTop", []interface{}{ctx, container, argumentsCopy})
	fake.containerTopMutex.Unlock()
	if fake.ContainerTopStub != nil {
		return fake.ContainerTopStub(ctx, container, arguments)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.containerTopReturns.result1, fake.containerTopReturns.result2
}

func (fake *FakeDockerClient) ContainerTopCallCount() int {
	fake.containerTopMutex.RLock()
	defer fake.containerTopMutex.RUnlock()
	return len(fake.containerTopArgsForCall)
}

func (fake *FakeDockerClient) ContainerTopArgsForCall(i int) (context.Context, string, []string) {
	fake.containerTopMutex.RLock()
	defer fake.containerTopMutex.RUnlock()
	return fake.containerTopArgsForCall[i].ctx, fake.containerTopArgsForCall[i].container, fake.containerTopArgsForCall[i].arguments
}

func (fake *FakeDockerClient) ContainerTopReturns(result1 types.ContainerProcessList, result2 error) {
	fake.ContainerTopStub = nil
	fake.containerTopReturns = struct {
		result1 types.ContainerProcessList
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerClient) ContainerTopReturnsOnCall(i int, result1 types.ContainerProcessList, result2 error) {
	fake.ContainerTopStub = nil
	if fake.containerTopReturnsOnCall == nil {
		fake.containerTopReturnsOnCall = make(map[int]struct {
			result1 types.ContainerProcessList
			result2 error
		})
	}
	fake.containerTopReturnsOnCall[i] = struct {
		result1 types.ContainerProcessList
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerClient) ContainerUnpause(ctx context.Context, container string) error {
	fake.containerUnpauseMutex.Lock()
	ret, specificReturn := fake.containerUnpauseReturnsOnCall[len(fake.containerUnpauseArgsForCall)]
	fake.containerUnpauseArgsForCall = append(fake.containerUnpauseArgsForCall, struct {
		ctx       context.Context
		container string
	}{ctx, container})
	fake.recordInvocation("ContainerUnpause", []interface{}{ctx, container})
	fake.containerUnpauseMutex.Unlock()
	if fake.ContainerUnpauseStub != nil {
		return fake.ContainerUnpauseStub(ctx, container)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.containerUnpauseReturns.result1
}

func (fake *FakeDockerClient) ContainerUnpauseCallCount() int {
	fake.containerUnpauseMutex.RLock()
	defer fake.containerUnpauseMutex.RUnlock()
	return len(fake.containerUnpauseArgsForCall)
}

func (fake *FakeDockerClient) ContainerUnpauseArgsForCall(i int) (context.Context, string) {
	fake.containerUnpauseMutex.RLock()
	defer fake.containerUnpauseMutex.RUnlock()
	return fake.containerUnpauseArgsForCall[i].ctx, fake.containerUnpauseArgsForCall[i].container
}

func (fake *FakeDockerClient) ContainerUnpauseReturns(result1 error) {
	fake.ContainerUnpauseStub = nil
	fake.containerUnpauseReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDockerClient) ContainerUnpauseReturnsOnCall(i int, result1 error) {
	fake.ContainerUnpauseStub = nil
	if fake.containerUnpauseReturnsOnCall == nil {
		fake.containerUnpauseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.containerUnpauseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDockerClient) ContainerUpdate(ctx context.Context, containerName string, updateConfig container.UpdateConfig) (container.ContainerUpdateOKBody, error) {
	fake.containerUpdateMutex.Lock()
	ret, specificReturn := fake.containerUpdateReturnsOnCall[len(fake.containerUpdateArgsForCall)]
	fake.containerUpdateArgsForCall = append(fake.containerUpdateArgsForCall, struct {
		ctx           context.Context
		containerName string
		updateConfig  container.UpdateConfig
	}{ctx, containerName, updateConfig})
	fake.recordInvocation("ContainerUpdate", []interface{}{ctx, containerName, updateConfig})
	fake.containerUpdateMutex.Unlock()
	if fake.ContainerUpdateStub != nil {
		return fake.ContainerUpdateStub(ctx, containerName, updateConfig)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.containerUpdateReturns.result1, fake.containerUpdateReturns.result2
}

func (fake *FakeDockerClient) ContainerUpdateCallCount() int {
	fake.containerUpdateMutex.RLock()
	defer fake.containerUpdateMutex.RUnlock()
	return len(fake.containerUpdateArgsForCall)
}

func (fake *FakeDockerClient) ContainerUpdateArgsForCall(i int) (context.Context, string, container.UpdateConfig) {
	fake.containerUpdateMutex.RLock()
	defer fake.containerUpdateMutex.RUnlock()
	return fake.containerUpdateArgsForCall[i].ctx, fake.containerUpdateArgsForCall[i].containerName, fake.containerUpdateArgsForCall[i].updateConfig
}

func (fake *FakeDockerClient) ContainerUpdateReturns(result1 container.ContainerUpdateOKBody, result2 error) {
	fake.ContainerUpdateStub = nil
	fake.containerUpdateReturns = struct {
		result1 container.ContainerUpdateOKBody
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerClient) ContainerUpdateReturnsOnCall(i int, result1 container.ContainerUpdateOKBody, result2 error) {
	fake.ContainerUpdateStub = nil
	if fake.containerUpdateReturnsOnCall == nil {
		fake.containerUpdateReturnsOnCall = make(map[int]struct {
			result1 container.ContainerUpdateOKBody
			result2 error
		})
	}
	fake.containerUpdateReturnsOnCall[i] = struct {
		result1 container.ContainerUpdateOKBody
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerClient) ContainerWait(ctx context.Context, container string) (int64, error) {
	fake.containerWaitMutex.Lock()
	ret, specificReturn := fake.containerWaitReturnsOnCall[len(fake.containerWaitArgsForCall)]
	fake.containerWaitArgsForCall = append(fake.containerWaitArgsForCall, struct {
		ctx       context.Context
		container string
	}{ctx, container})
	fake.recordInvocation("ContainerWait", []interface{}{ctx, container})
	fake.containerWaitMutex.Unlock()
	if fake.ContainerWaitStub != nil {
		return fake.ContainerWaitStub(ctx, container)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.containerWaitReturns.result1, fake.containerWaitReturns.result2
}

func (fake *FakeDockerClient) ContainerWaitCallCount() int {
	fake.containerWaitMutex.RLock()
	defer fake.containerWaitMutex.RUnlock()
	return len(fake.containerWaitArgsForCall)
}

func (fake *FakeDockerClient) ContainerWaitArgsForCall(i int) (context.Context, string) {
	fake.containerWaitMutex.RLock()
	defer fake.containerWaitMutex.RUnlock()
	return fake.containerWaitArgsForCall[i].ctx, fake.containerWaitArgsForCall[i].container
}

func (fake *FakeDockerClient) ContainerWaitReturns(result1 int64, result2 error) {
	fake.ContainerWaitStub = nil
	fake.containerWaitReturns = struct {
		result1 int64
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerClient) ContainerWaitReturnsOnCall(i int, result1 int64, result2 error) {
	fake.ContainerWaitStub = nil
	if fake.containerWaitReturnsOnCall == nil {
		fake.containerWaitReturnsOnCall = make(map[int]struct {
			result1 int64
			result2 error
		})
	}
	fake.containerWaitReturnsOnCall[i] = struct {
		result1 int64
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerClient) CopyFromContainer(ctx context.Context, container string, srcPath string) (io.ReadCloser, types.ContainerPathStat, error) {
	fake.copyFromContainerMutex.Lock()
	ret, specificReturn := fake.copyFromContainerReturnsOnCall[len(fake.copyFromContainerArgsForCall)]
	fake.copyFromContainerArgsForCall = append(fake.copyFromContainerArgsForCall, struct {
		ctx       context.Context
		container string
		srcPath   string
	}{ctx, container, srcPath})
	fake.recordInvocation("CopyFromContainer", []interface{}{ctx, container, srcPath})
	fake.copyFromContainerMutex.Unlock()
	if fake.CopyFromContainerStub != nil {
		return fake.CopyFromContainerStub(ctx, container, srcPath)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.copyFromContainerReturns.result1, fake.copyFromContainerReturns.result2, fake.copyFromContainerReturns.result3
}

func (fake *FakeDockerClient) CopyFromContainerCallCount() int {
	fake.copyFromContainerMutex.RLock()
	defer fake.copyFromContainerMutex.RUnlock()
	return len(fake.copyFromContainerArgsForCall)
}

func (fake *FakeDockerClient) CopyFromContainerArgsForCall(i int) (context.Context, string, string) {
	fake.copyFromContainerMutex.RLock()
	defer fake.copyFromContainerMutex.RUnlock()
	return fake.copyFromContainerArgsForCall[i].ctx, fake.copyFromContainerArgsForCall[i].container, fake.copyFromContainerArgsForCall[i].srcPath
}

func (fake *FakeDockerClient) CopyFromContainerReturns(result1 io.ReadCloser, result2 types.ContainerPathStat, result3 error) {
	fake.CopyFromContainerStub = nil
	fake.copyFromContainerReturns = struct {
		result1 io.ReadCloser
		result2 types.ContainerPathStat
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDockerClient) CopyFromContainerReturnsOnCall(i int, result1 io.ReadCloser, result2 types.ContainerPathStat, result3 error) {
	fake.CopyFromContainerStub = nil
	if fake.copyFromContainerReturnsOnCall == nil {
		fake.copyFromContainerReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
			result2 types.ContainerPathStat
			result3 error
		})
	}
	fake.copyFromContainerReturnsOnCall[i] = struct {
		result1 io.ReadCloser
		result2 types.ContainerPathStat
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDockerClient) CopyToContainer(ctx context.Context, container string, path string, content io.Reader, options types.CopyToContainerOptions) error {
	fake.copyToContainerMutex.Lock()
	ret, specificReturn := fake.copyToContainerReturnsOnCall[len(fake.copyToContainerArgsForCall)]
	fake.copyToContainerArgsForCall = append(fake.copyToContainerArgsForCall, struct {
		ctx       context.Context
		container string
		path      string
		content   io.Reader
		options   types.CopyToContainerOptions
	}{ctx, container, path, content, options})
	fake.recordInvocation("CopyToContainer", []interface{}{ctx, container, path, content, options})
	fake.copyToContainerMutex.Unlock()
	if fake.CopyToContainerStub != nil {
		return fake.CopyToContainerStub(ctx, container, path, content, options)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.copyToContainerReturns.result1
}

func (fake *FakeDockerClient) CopyToContainerCallCount() int {
	fake.copyToContainerMutex.RLock()
	defer fake.copyToContainerMutex.RUnlock()
	return len(fake.copyToContainerArgsForCall)
}

func (fake *FakeDockerClient) CopyToContainerArgsForCall(i int) (context.Context, string, string, io.Reader, types.CopyToContainerOptions) {
	fake.copyToContainerMutex.RLock()
	defer fake.copyToContainerMutex.RUnlock()
	return fake.copyToContainerArgsForCall[i].ctx, fake.copyToContainerArgsForCall[i].container, fake.copyToContainerArgsForCall[i].path, fake.copyToContainerArgsForCall[i].content, fake.copyToContainerArgsForCall[i].options
}

func (fake *FakeDockerClient) CopyToContainerReturns(result1 error) {
	fake.CopyToContainerStub = nil
	fake.copyToContainerReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDockerClient) CopyToContainerReturnsOnCall(i int, result1 error) {
	fake.CopyToContainerStub = nil
	if fake.copyToContainerReturnsOnCall == nil {
		fake.copyToContainerReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.copyToContainerReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDockerClient) ContainersPrune(ctx context.Context, pruneFilters filters.Args) (types.ContainersPruneReport, error) {
	fake.containersPruneMutex.Lock()
	ret, specificReturn := fake.containersPruneReturnsOnCall[len(fake.containersPruneArgsForCall)]
	fake.containersPruneArgsForCall = append(fake.containersPruneArgsForCall, struct {
		ctx          context.Context
		pruneFilters filters.Args
	}{ctx, pruneFilters})
	fake.recordInvocation("ContainersPrune", []interface{}{ctx, pruneFilters})
	fake.containersPruneMutex.Unlock()
	if fake.ContainersPruneStub != nil {
		return fake.ContainersPruneStub(ctx, pruneFilters)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.containersPruneReturns.result1, fake.containersPruneReturns.result2
}

func (fake *FakeDockerClient) ContainersPruneCallCount() int {
	fake.containersPruneMutex.RLock()
	defer fake.containersPruneMutex.RUnlock()
	return len(fake.containersPruneArgsForCall)
}

func (fake *FakeDockerClient) ContainersPruneArgsForCall(i int) (context.Context, filters.Args) {
	fake.containersPruneMutex.RLock()
	defer fake.containersPruneMutex.RUnlock()
	return fake.containersPruneArgsForCall[i].ctx, fake.containersPruneArgsForCall[i].pruneFilters
}

func (fake *FakeDockerClient) ContainersPruneReturns(result1 types.ContainersPruneReport, result2 error) {
	fake.ContainersPruneStub = nil
	fake.containersPruneReturns = struct {
		result1 types.ContainersPruneReport
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerClient) ContainersPruneReturnsOnCall(i int, result1 types.ContainersPruneReport, result2 error) {
	fake.ContainersPruneStub = nil
	if fake.containersPruneReturnsOnCall == nil {
		fake.containersPruneReturnsOnCall = make(map[int]struct {
			result1 types.ContainersPruneReport
			result2 error
		})
	}
	fake.containersPruneReturnsOnCall[i] = struct {
		result1 types.ContainersPruneReport
		result2 error
	}{result1, result2}
}

func (fake *FakeDockerClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.imageBuildMutex.RLock()
	defer fake.imageBuildMutex.RUnlock()
	fake.imageCreateMutex.RLock()
	defer fake.imageCreateMutex.RUnlock()
	fake.imageHistoryMutex.RLock()
	defer fake.imageHistoryMutex.RUnlock()
	fake.imageImportMutex.RLock()
	defer fake.imageImportMutex.RUnlock()
	fake.imageInspectWithRawMutex.RLock()
	defer fake.imageInspectWithRawMutex.RUnlock()
	fake.imageListMutex.RLock()
	defer fake.imageListMutex.RUnlock()
	fake.imageLoadMutex.RLock()
	defer fake.imageLoadMutex.RUnlock()
	fake.imagePullMutex.RLock()
	defer fake.imagePullMutex.RUnlock()
	fake.imagePushMutex.RLock()
	defer fake.imagePushMutex.RUnlock()
	fake.imageRemoveMutex.RLock()
	defer fake.imageRemoveMutex.RUnlock()
	fake.imageSearchMutex.RLock()
	defer fake.imageSearchMutex.RUnlock()
	fake.imageSaveMutex.RLock()
	defer fake.imageSaveMutex.RUnlock()
	fake.imageTagMutex.RLock()
	defer fake.imageTagMutex.RUnlock()
	fake.imagesPruneMutex.RLock()
	defer fake.imagesPruneMutex.RUnlock()
	fake.containerAttachMutex.RLock()
	defer fake.containerAttachMutex.RUnlock()
	fake.containerCommitMutex.RLock()
	defer fake.containerCommitMutex.RUnlock()
	fake.containerCreateMutex.RLock()
	defer fake.containerCreateMutex.RUnlock()
	fake.containerDiffMutex.RLock()
	defer fake.containerDiffMutex.RUnlock()
	fake.containerExecAttachMutex.RLock()
	defer fake.containerExecAttachMutex.RUnlock()
	fake.containerExecCreateMutex.RLock()
	defer fake.containerExecCreateMutex.RUnlock()
	fake.containerExecInspectMutex.RLock()
	defer fake.containerExecInspectMutex.RUnlock()
	fake.containerExecResizeMutex.RLock()
	defer fake.containerExecResizeMutex.RUnlock()
	fake.containerExecStartMutex.RLock()
	defer fake.containerExecStartMutex.RUnlock()
	fake.containerExportMutex.RLock()
	defer fake.containerExportMutex.RUnlock()
	fake.containerInspectMutex.RLock()
	defer fake.containerInspectMutex.RUnlock()
	fake.containerInspectWithRawMutex.RLock()
	defer fake.containerInspectWithRawMutex.RUnlock()
	fake.containerKillMutex.RLock()
	defer fake.containerKillMutex.RUnlock()
	fake.containerListMutex.RLock()
	defer fake.containerListMutex.RUnlock()
	fake.containerLogsMutex.RLock()
	defer fake.containerLogsMutex.RUnlock()
	fake.containerPauseMutex.RLock()
	defer fake.containerPauseMutex.RUnlock()
	fake.containerRemoveMutex.RLock()
	defer fake.containerRemoveMutex.RUnlock()
	fake.containerRenameMutex.RLock()
	defer fake.containerRenameMutex.RUnlock()
	fake.containerResizeMutex.RLock()
	defer fake.containerResizeMutex.RUnlock()
	fake.containerRestartMutex.RLock()
	defer fake.containerRestartMutex.RUnlock()
	fake.containerStatPathMutex.RLock()
	defer fake.containerStatPathMutex.RUnlock()
	fake.containerStatsMutex.RLock()
	defer fake.containerStatsMutex.RUnlock()
	fake.containerStartMutex.RLock()
	defer fake.containerStartMutex.RUnlock()
	fake.containerStopMutex.RLock()
	defer fake.containerStopMutex.RUnlock()
	fake.containerTopMutex.RLock()
	defer fake.containerTopMutex.RUnlock()
	fake.containerUnpauseMutex.RLock()
	defer fake.containerUnpauseMutex.RUnlock()
	fake.containerUpdateMutex.RLock()
	defer fake.containerUpdateMutex.RUnlock()
	fake.containerWaitMutex.RLock()
	defer fake.containerWaitMutex.RUnlock()
	fake.copyFromContainerMutex.RLock()
	defer fake.copyFromContainerMutex.RUnlock()
	fake.copyToContainerMutex.RLock()
	defer fake.copyToContainerMutex.RUnlock()
	fake.containersPruneMutex.RLock()
	defer fake.containersPruneMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeDockerClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ docker.DockerClient = new(FakeDockerClient)
